[
  {
    "url": "https://docs.lambda-forge.com/articles/custom-domain-name/",
    "title": "Custom Domain Name - Lambda Forge",
    "content": "Custom Domain Name - Lambda Forge Skip to content Lambda Forge Custom Domain Name Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Custom Domain Name Table of contents Prerequisites Step 1: Request a Certificate in AWS Certificate Manager Step 2: Validate Your Domain Step 3: Create a Custom Domain Name in API Gateway Step 4: Configure the Base Path Mapping Step 5: Update Your DNS Records Step 6: Test Your Custom Domain Conclusion Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Prerequisites Step 1: Request a Certificate in AWS Certificate Manager Step 2: Validate Your Domain Step 3: Create a Custom Domain Name in API Gateway Step 4: Configure the Base Path Mapping Step 5: Update Your DNS Records Step 6: Test Your Custom Domain Conclusion How to Configure a Custom Domain Name for API Gateway Configuring a custom domain name for your API Gateway allows you to present a professional and brand-consistent URL to your users. This step-by-step guide will walk you through the process of setting up a custom domain name for your API Gateway in AWS. Prerequisites Before you begin, make sure you have the following: An AWS account. A deployed API in API Gateway. A registered domain name. You can use Amazon Route 53 or any other domain registrar. An SSL certificate for your custom domain name in AWS Certificate Manager (ACM). This is required for HTTPS. Step 1: Request a Certificate in AWS Certificate Manager Go to the AWS Certificate Manager: In the AWS Management Console, navigate to ACM. Request a Certificate: Click on \u201cRequest a certificate\u201d and choose \u201cRequest a public certificate\u201d. Add your domain names: Enter your custom domain name. You can add multiple names if needed. Choose validation method: You can validate your domain ownership via DNS or email. DNS validation is recommended for its simplicity and speed. Review and request: Review your details and click \u201cConfirm and request\u201d. Step 2: Validate Your Domain For DNS Validation: Add the CNAME record provided by ACM to your DNS configuration. This process varies depending on your DNS provider. For Email Validation: Check the email associated with your domain registration and follow the instructions in the email from AWS. Step 3: Create a Custom Domain Name in API Gateway Navigate to API Gateway: In the AWS Management Console, go to API Gateway. Create Custom Domain Name: Click on \u201cCustom Domain Names\u201d in the sidebar, then \u201cCreate\u201d. Configure your domain name: Enter your domain name and select the ACM certificate you created earlier. Set up Endpoint Configuration: Choose the endpoint type. You can choose from an \u201cEdge-optimized\u201d (default and recommended for global clients) or \u201cRegional\u201d (if your users are primarily in one region) endpoint. Save the Custom Domain Name: Click on \u201cSave\u201d to create your custom domain name. Step 4: Configure the Base Path Mapping Select your custom domain name: From the list of custom domain names, click on the one you just created. Create a new Base Path Mapping: Click on the \u201cBase Path Mappings\u201d section and then \u201cAdd new base path\u201d. Set up the Base Path: Choose the destination API and stage for your custom domain. The base path allows you to direct traffic to different APIs or stages from the same domain. Save your Base Path Mapping: Click on \u201cSave\u201d. Step 5: Update Your DNS Records Get the API Gateway domain name: After saving your custom domain name in API Gateway, you'll get a target domain name. This is different from your custom domain. Create a CNAME record: In your domain\u2019s DNS settings, create a CNAME record pointing your custom domain to the target domain name provided by API Gateway. Step 6: Test Your Custom Domain After your DNS changes propagate, test your custom domain by sending requests to your API through the new domain name. Conclusion You have successfully configured a custom domain name for your API Gateway. This not only enhances your API's branding but also provides a more secure and professional way to present your services to the world. If you encounter any issues, AWS documentation and support forums are great resources for troubleshooting and getting additional help. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/real-time-chat/",
    "title": "Real-Time Chat - Lambda Forge",
    "content": "Real-Time Chat - Lambda Forge Skip to content Lambda Forge Real-Time Chat Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Building a Real-Time Chat Application with WebSockets and DynamoDB in a Serverless Architecture Coming soon... Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/articles/deploying-external-library-as-layers/",
    "title": "Deploying External Library as Layers - Lambda Forge",
    "content": "Deploying External Library as Layers - Lambda Forge Skip to content Lambda Forge Deploying External Library as Layers Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Deploying External Library as Layers Table of contents Setting Up The Environment Preparing the Layer Package Creating and Using the Lambda Layer Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Setting Up The Environment Preparing the Layer Package Creating and Using the Lambda Layer Deploying an External Library to AWS Lambda as a Layer This guide outlines the steps to deploy an external library, such as the qrcode library, to AWS Lambda as a Layer. AWS Lambda Layers serve as a repository for managing common code or data shared across multiple functions. By deploying the qrcode library as a Layer, the library can be utilized in various Lambda functions without needing to be included in each function's deployment package. Although the qrcode library is used as an example, this method applies universally to any library you wish to deploy in this manner. Setting Up The Environment mkdir packages cd packages Initialize a virtual environment within this directory and activate it: python3 -m venv venv source venv/bin/activate Create a directory named python within the current directory and navigate into it: mkdir python cd python It is crucial to name this directory as python as it aligns with Lambda Layers' requirements. Install the qrcode library directly into this directory: pip install qrcode -t . This command uses pip to install the library into the current python directory. After installation, you can attempt to list the directory contents. You should see the installed packages. Preparing the Layer Package Remove unnecessary files, specifically those with the .dist-info extension, to conserve space. These files are not needed for the Lambda Layer: rm -rf *dist-info Return to the parent directory: cd .. Zip the python directory, naming the zip file qr-code-lambda-package.zip: zip -r qr-code-lambda-package.zip python You should now have the zip file in your current directory. Create a s3 bucket and upload your zip file to it: aws s3 cp qr-code-lambda-package.zip s3://your-s3-bucket-name/ Verify the upload by checking the S3 bucket and ensuring the zip file is present. Note the object URL for later use. Creating and Using the Lambda Layer Navigate to the AWS Lambda console and select the Layers option. Click on Create layer and input the necessary configuration details. Choose the Upload a file from Amazon S3 option and paste the URL of the bucket containing the zip file you created earlier. Finalize by clicking \"Add\". That's it! You've successfully deployed the qrcode library to AWS Lambda as a Layer. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/web-scraper/",
    "title": "Web Scraper - Lambda Forge",
    "content": "Web Scraper - Lambda Forge Skip to content Lambda Forge Web Scraper Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Web Scraper Table of contents Dynamo DB Lambda Layers Incorporating Requests and Beautiful Soup via Public Layers Developing The Web Scraper Building a Web Scraper with Pagination Handling Using a While Loop Building a Web Scraper with Pagination Handling Using SNS Configuring The Web Scraper Scheduling Executions With Event Bridge Developing an Endpoint for Data Access Launching Our Web Scraper and Data Visualization Endpoint Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Dynamo DB Lambda Layers Incorporating Requests and Beautiful Soup via Public Layers Developing The Web Scraper Building a Web Scraper with Pagination Handling Using a While Loop Building a Web Scraper with Pagination Handling Using SNS Configuring The Web Scraper Scheduling Executions With Event Bridge Developing an Endpoint for Data Access Launching Our Web Scraper and Data Visualization Endpoint Creating a Serverless Web Scraper: Integrating DynamoDB, SNS and EventBridge In this section, we will develop a serverless web scraper designed to extract informations about books from https://books.toscrape.com/ utilizing the Requests library and Beautiful Soup. The retrieved data will be stored in DynamoDB, enabling us to perform queries via an endpoint. Additionally, we will cover how to configure our Lambda function to execute daily, ensuring our dataset remains current and accurate. Dynamo DB Considering the write access to our database will be exclusively reserved for the scraper, maintaining three separate databases for each deployment stage is unnecessary. Therefore, let's just create a singular DynamoDB table designed to serve all three environments uniformly. Instead of setting up each environment's details separately in the cdk.json file, like we did to the users table, we'll make things simpler by creating a single Books table on the AWS console and placing its ARN directly into our DynamoDB class. infra/services/dynamo_db.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18class DynamoDB: def __init__(self, scope, resources: dict) -> None: self.users_table = dynamo_db.Table.from_table_arn( scope, \"UsersTable\", resources[\"arns\"][\"users_table\"], ) self.books_table = dynamo_db.Table.from_table_arn( scope, \"BooksTable\", \"$BOOKS-TABLE-ARN\", ) Lambda Layers Another essential aspect of our project involves leveraging external libraries like requests and Beautiful Soup for our web scraping tasks. Since these libraries are not built into Python's standard library, we'll need to incorporate them into our AWS Lambda functions as Lambda Layers. Incorporating Requests and Beautiful Soup via Public Layers The requests and Beautiful Soup libraries are widely used and recognized for their utility in web scraping and data extraction tasks. Fortunately, AWS Lambda offers these libraries as public layers, simplifying the process of integrating them into your projects without the need to create custom layers. For projects utilizing Python 3.9, we can leverage the specific Amazon Resource Names (ARNs) for both requests and Beautiful Soup libraries made available through Klayers. This provides an efficient way to add these libraries to your Lambda functions. You can explore the complete list of public layers for Python 3.9 in the us-east-2 region here. Here are the ARNs you'll need: Requests: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19 Beautiful Soup 4: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-beautifulsoup4:7 Let's add them both to our Layers class. infra/services/layers.pyfrom aws_cdk import aws_lambda as _lambda class Layers: def __init__(self, scope) -> None: self.requests_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"RequestsLayer\", layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19\", ) self.bs4_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"BS4Layer\", layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-beautifulsoup4:7\", ) Additionally, include the libraries in the requirements.txt file. requirements.txt16 17requests==2.28.1 beautifulsoup4==4.12.3 Developing The Web Scraper Our web scraper will extract the following details: upc, title, price, category, stock, description and url. Let's create it with forge. forge function scraper --description \"Web scraper to populate Dynamo with books data\" --no-api --belongs-to books Remember, although users can access the scraper's results, the scraper itself won't serve as a direct endpoint. We've included the --no-api flag in our Forge setup to signify that this function won't be connected to the API Gateway. Its primary role is to enrich our database. Additionally, the --belongs-to flag was used to organize it within the books directory, aligning it with related functions planned for the future. Here is the structure created for the books directory: functions \u251c\u2500\u2500 books \u251c\u2500\u2500 scraper \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 unit.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Building a Web Scraper with Pagination Handling Using a While Loop Our focus is on understanding how AWS resources are integrated with Lambda Forge, not on the intricacies of developing a web scraper. Therefore, we will not cover the source code in detail. Nevertheless, we encourage you to experiment with creating your own web scraper, as the core concepts we're discussing will remain applicable. Below, you'll find the source code accompanied by comments that explain the concepts it illustrates. functions/books/scraper/main.pyimport os import re import boto3 import requests from bs4 import BeautifulSoup BASE_URL = \"https://books.toscrape.com\" def lambda_handler(event, context): # DynamoDB table name for storing books information BOOKS_TABLE_NAME = os.environ.get(\"BOOKS_TABLE_NAME\") # Initialize a DynamoDB resource dynamodb = boto3.resource(\"dynamodb\") # Reference the DynamoDB table books_table = dynamodb.Table(BOOKS_TABLE_NAME) # Determine the URL to scrape, defaulting to BASE_URL url = event.get(\"url\") or BASE_URL while url: # Fetch and parse the webpage at the given URL response = requests.get(url) soup = BeautifulSoup(response.text, \"html.parser\") for article in soup.find_all(\"article\"): # Extract book details title = article.find(\"h3\").find(\"a\").get(\"title\").title() price = article.find(\"p\", {\"class\": \"price_color\"}).get_text()[1:] # Correct the href if it doesn't contain \"catalogue/\" href = article.find(\"h3\").find(\"a\").get(\"href\") if \"catalogue/\" not in href: href = f\"catalogue/{href}\" # Fetch and parse the book detail page url = f\"{BASE_URL}/{href}\" detail_response = requests.get(url) detail_soup = BeautifulSoup(detail_response.text, \"html.parser\") # Extract additional details from the book detail page upc = detail_soup.find(\"th\", string=\"UPC\").find_next(\"td\").get_text().strip() category = ( detail_soup.find(\"ul\", {\"class\", \"breadcrumb\"}) .find_all(\"li\")[2] .text.strip() ) stock = ( detail_soup.find(\"p\", {\"class\": \"instock availability\"}).get_text().strip() ) stock = re.search(r\"\\d+\", stock)[0] description = detail_soup.find(\"div\", {\"id\": \"product_description\"}) if description: description = description.find_next(\"p\").get_text() # Construct the item to store in DynamoDB item = { \"PK\": upc, \"category\": category, \"title\": title, \"price\": price, \"description\": description, \"stock\": stock, \"url\": url, } # Store the item in DynamoDB books_table.put_item(Item=item) # Check for and process the next page next_page = soup.find(\"li\", {\"class\": \"next\"}) if next_page: next_href = next_page.find(\"a\")[\"href\"] if \"catalogue/\" not in next_href: next_href = f\"catalogue/{next_href}\" url = f\"{BASE_URL}/{next_href}\" else: url = None Due to AWS's predefined operational constraints, Lambda functions are explicitly engineered for rapid execution, with a maximum duration limit of 15 minutes. To evaluate the efficiency of our function, we will incorporate print statements that monitor execution time throughout our local testing phase. Execution time: 1024.913999080658 seconds The execution time approaches nearly 17 minutes, exceeding the maximum duration allowed for a Lambda function. Consequently, we need to seek alternative strategies to ensure our scraper remains compliant with the limitations. Utilizing a while loop within a solitary AWS Lambda function to perform book data extraction from the website is functional yet lacks efficiency and scalability. This is particularly pertinent within the AWS ecosystem, which is rich in services tailored for distributed computing and intricate task orchestration. Building a Web Scraper with Pagination Handling Using SNS Amazon Simple Notification Service (SNS) is a fully managed messaging service provided by AWS, enabling seamless communication between distributed systems. It operates on a publish-subscribe model, where messages are published to topics and subscribers receive notifications from these topics. With support for various types of subscriptions including HTTP, SQS, Lambda, email, and SMS, SNS ensures reliable and scalable message delivery across multiple AWS regions. It also offers features like message filtering, retry mechanisms, and dead-letter queues to enhance message processing and system resilience. Instead of using a while loop to process all pages in a single function, let's design a Lambda function to process a maximum of 10 pages. After completing these pages, it should dispatch a message with the URL of the next starting page to an SNS topic. This triggers another Lambda function dedicated to harvesting book information from the subsequent 10 pages. As an initial step, we have to integrate SNS into our Services class. forge service sns A new sns.py file was created on infra/services, so create a new SNS topic on the AWS console and place it's ARN on the SNS class. infra/services/sns.pyfrom aws_cdk import aws_lambda_event_sources import aws_cdk.aws_sns as sns class SNS: def __init__(self, scope, resources, stage) -> None: self.stage = stage self.books_scraper_topic = sns.Topic.from_topic_arn( scope, \"BooksScraperTopic\", topic_arn=\"$TOPIC-ARN\", ) def create_trigger(self, topic, function, stages=None): if stages and self.stage not in stages: return sns_subscription = aws_lambda_event_sources.SnsEventSource(topic) function.add_event_source(sns_subscription) Note that the SNS class contains a handy helper method, streamlining the process of establishing triggers that connect an SNS topic to a Lambda function. Now, let's revise the original code to eliminate the while loop that processes all pages and instead publish a message to SNS containing the URL of the new starting point. functions/books/scraper/main.pyimport os import re import json import time import boto3 import requests from bs4 import BeautifulSoup BASE_URL = \"https://books.toscrape.com\" def lambda_handler(event, context): # Get the DynamoDB table name and SNS topic ARN from environment variables. BOOKS_TABLE_NAME = os.environ.get(\"BOOKS_TABLE_NAME\", \"Books\") SNS_TOPIC_ARN = os.environ.get(\"SNS_TOPIC_ARN\") # Initialize the DynamoDB and SNS clients. dynamodb = boto3.resource(\"dynamodb\") sns = boto3.client(\"sns\") # Reference the DynamoDB table. books_table = dynamodb.Table(BOOKS_TABLE_NAME) # Determine the URL to scrape, defaulting to BASE_URL try: url = json.loads(event['Records'][0]['Sns']['Message'].replace(\"'\", '\"'))[\"url\"] except: url = BASE_URL # Keep track of the number of pages processed pages_processed = 0 # Maximum number of pages to process MAX_PAGES = 10 while pages_processed < MAX_PAGES: response = requests.get(url) soup = BeautifulSoup(response.text, \"html.parser\") for article in soup.find_all(\"article\"): # Extract book details title = article.find(\"h3\").find(\"a\").get(\"title\").title() price = article.find(\"p\", {\"class\": \"price_color\"}).get_text()[1:] # Correct the href if it doesn't contain \"catalogue/\" href = article.find(\"h3\").find(\"a\").get(\"href\") if \"catalogue/\" not in href: href = f\"catalogue/{href}\" # Fetch and parse the book detail page detail_url = f\"{BASE_URL}/{href}\" detail_response = requests.get(detail_url) detail_soup = BeautifulSoup(detail_response.text, \"html.parser\") # Extract additional details from the book detail page upc = detail_soup.find(\"th\", string=\"UPC\").find_next(\"td\").get_text().strip() category = ( detail_soup.find(\"ul\", {\"class\", \"breadcrumb\"}) .find_all(\"li\")[2] .text.strip() ) description = detail_soup.find(\"div\", {\"id\": \"product_description\"}) stock = ( detail_soup.find(\"p\", {\"class\": \"instock availability\"}) .get_text().strip() ) stock = re.search(r\"\\d+\", stock)[0] if description: description = description.find_next(\"p\").get_text() # Construct the item to store in DynamoDB item = { \"PK\": upc, \"category\": category, \"title\": title, \"price\": price, \"description\": description, \"stock\": stock, \"url\": detail_url, } # Store the item in DynamoDB books_table.put_item(Item=item) # Increment the number of pages processed pages_processed += 1 # Check for the next page next_page = soup.find(\"li\", {\"class\": \"next\"}) if not next_page: break # Correct the href if it doesn't contain \"catalogue/\" next_href = next_page.find(\"a\")[\"href\"] if \"catalogue/\" not in next_href: next_href = f\"catalogue/{next_href}\" # Construct the URL for the next page url = f\"{BASE_URL}/{next_href}\" if next_page: # Publish a message to the SNS topic to process the next 10 pages sns.publish( TopicArn=SNS_TOPIC_ARN, Message=str({\"url\": url}), Subject=f\"Process next {MAX_PAGES} pages of books\", ) Let's measure how long that function took to run locally: Execution time: 167.53530287742615 seconds Fantastic, it took under 3 minutes! This approach ensures that we never exceed the 15 minutes timeout limit, as each time a new message is published to SNS, the timeout counter is refreshed, allowing continuous execution without interruption. Configuring The Web Scraper Now that we have developed our function, let's proceed to configure the necessary AWS resources for its executions on the cloud. functions/books/scraper/config.pyfrom infra.services import Services class ScraperConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Scraper\", path=\"./functions/books\", description=\"Web scraper to populate Dynamo with books data\", directory=\"scraper\", timeout=5, layers=[services.layers.requests_layer, services.layers.bs4_layer], environment={ \"BOOKS_TABLE_NAME\": services.dynamo_db.books_table.table_name, \"SNS_TOPIC_ARN\": services.sns.books_scraper_topic.topic_arn } ) services.dynamo_db.books_table.grant_write_data(function) services.sns.create_trigger(services.sns.books_scraper_topic, function) services.sns.books_scraper_topic.grant_publish(function) This configuration file outlines the setup and permissions for a Lambda function, detailing: Timeout: Specifies a maximum duration of 5 minutes for Lambda execution. Layers: Adds the requests and bs4 layers to the Lambda function. Environment Variables: Establishes the required environment variables for operation. DynamoDB Access: Provides the Lambda function with write access to the DynamoDB Books table. SNS Trigger: Utilizes the SNS class helper method to link an SNS topic with the production Lambda function. SNS Publishing Permissions: Empowers the Lambda function to publish messages to the books topic. Scheduling Executions With Event Bridge The current configuration file equips us to execute the Lambda function as needed. However, it necessitates manual intervention for each run, which is an impractical approach for dynamic tasks like web scraping. The crux of the issue lies in the volatile nature of our target: website data, such as book prices and inventory, can change unpredictably. To mitigate this, we must ensure our web scraper operates automatically at regular intervals, thus capturing updates without manual oversight. By leveraging AWS EventBridge, we can schedule our Lambda function to run periodically, ensuring our data collection remains current with minimal effort. To integrate AWS EventBridge for scheduling tasks, we begin by creating an EventBridge class using Forge. This is achieved with the following command: forge service event_bridge After executing the command, a new file named event_bridge.py is generated within the infra/services directory. Let's explore its contents and functionalities: infra/services/event_bridge.pyimport aws_cdk.aws_events as events import aws_cdk.aws_events_targets as targets class EventBridge: def __init__(self, scope, resources, stage) -> None: self.scope = scope self.stage = stage def create_rule(self, name, expression, target, stages=None): if stages is not None and self.stage not in stages: return events.Rule( self.scope, name, schedule=events.Schedule.expression(expression), targets=[targets.LambdaFunction(handler=target)], ) This class introduces a streamlined method for creating EventBridge rules, enabling the scheduling of Lambda function executions. Before we proceed, it's crucial to acknowledge that we're operating within a multi-stage deployment environment. Our immediate task involves configuring the Scraper function to activate based on a scheduled rule. However, a pertinent question arises: Should we initiate the triggering of three distinct functions simultaneously? Of course not, especially when considering efficiency and resource management. More precisely, is there a need for creating three scrapers when, in reality, only one is enough to populate the database? Bearing this consideration in mind, it's wise to implement a few minor adjustments. Our goal is to streamline the process, thereby avoiding the creation of unnecessary scrapers. First, let's modify the LambdaStack class to send also the context to the ScraperConfig class. infra/stacks/lambda_stack.py42 43 # Books ScraperConfig(self.services, context) Now, let's modify our configuration class to accept the context as an additional argument in its constructor. By incorporating the context, we can strategically condition the creation of the function based on the deployment stage. functions/books/scraper/config.pyfrom infra.services import Services class ScraperConfig: def __init__(self, services: Services, context) -> None: if context.stage != \"Prod\": return function = services.aws_lambda.create_function( name=\"Scraper\", path=\"./functions/books\", description=\"Web scraper to populate Dynamo with books data\", directory=\"scraper\", timeout=5, layers=[services.layers.requests_layer, services.layers.bs4_layer], environment={ \"BOOKS_TABLE_NAME\": services.dynamo_db.books_table.table_name, \"SNS_TOPIC_ARN\": services.sns.books_scraper_topic.topic_arn } ) services.dynamo_db.books_table.grant_write_data(function) services.sns.create_trigger(services.sns.books_scraper_topic, function) services.sns.books_scraper_topic.grant_publish(function) services.event_bridge.create_rule( name=\"ScraperRule\", expression=\"cron(0 12 ? * * *)\", target=function, ) The cron expression cron(0 12 ? * * *) configures a schedule to initiate an action every day at 12 PM UTC. Now, we're streamlining our deployment by creating the Lambda function and its essential resources exclusively for the staging environment that will be actively utilized. Developing an Endpoint for Data Access Let's create an endpoint that returns all the stored data from our database or allows filtering by category, facilitating easy access and manipulation of the data. forge function list_books --method \"GET\" --description \"A function to fetch books from DynamoDB, optionally filtered by category.\" --belongs-to books --public The file has been created within the books directory, as initially planned. functions \u251c\u2500\u2500 books \u251c\u2500\u2500 list_books \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 integration.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 unit.py \u251c\u2500\u2500 scraper \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 unit.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py To optimize data retrieval by category from our DynamoDB table, we need to create a Global Secondary Index (GSI) on the Books Table. This index enables efficient querying and filtering of data based on the category attribute, without the need for scanning the entire table. Go to the DynamoDB section within the AWS Management Console and select the Books Table. Click on the Indexes tab next to the table details, then press Create index. In the creation form, set the partition key to your category column. Name your index as CategoryIndex. After configuring these details, review your settings and confirm by clicking Create index. Having established our index, we can utilize it to precisely and efficiently fetch data by category when needed, significantly optimizing our query performance. functions/books/list_books/main.pyimport json import os from dataclasses import dataclass from typing import List, Optional import boto3 from boto3.dynamodb.conditions import Key @dataclass class Input: category: Optional[str] @dataclass class Book: id: str title: str price: str category: str stock: str description: str url: str @dataclass class Output: data: List[Book] def lambda_handler(event, context): # Initialize a DynamoDB client dynamodb = boto3.resource(\"dynamodb\") # Get the name of the table from the environment variable BOOKS_TABLE_NAME = os.environ[\"BOOKS_TABLE_NAME\"] # Create a DynamoDB table resource table = dynamodb.Table(BOOKS_TABLE_NAME) # Check if a category is specified in the query string parameters category = ( event[\"queryStringParameters\"].get(\"category\") if event[\"queryStringParameters\"] else None ) processed_items = [] last_evaluated_key = None # Handle pagination while True: scan_kwargs = {} if category: scan_kwargs.update({ 'IndexName': \"CategoryIndex\", 'KeyConditionExpression': Key(\"category\").eq(category.title()) }) if last_evaluated_key: scan_kwargs['ExclusiveStartKey'] = last_evaluated_key if category: response = table.query(**scan_kwargs) else: response = table.scan(**scan_kwargs) items = response.get(\"Items\", []) # Renaming 'PK' attribute to 'id' in each item processed_items.extend( [{\"id\": item[\"PK\"], **{k: v for k, v in item.items() if k != \"PK\"}} for item in items] ) last_evaluated_key = response.get('LastEvaluatedKey') if not last_evaluated_key: break return {\"statusCode\": 200, \"body\": json.dumps({\"data\": processed_items})} Now Let's configure the function functions/books/list_books/config.pyfrom infra.services import Services class ListBooksConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"ListBooks\", path=\"./functions/books\", description=\"A function to fetch books from DynamoDB, optionally filtered by category.\", directory=\"list_books\", environment={\"BOOKS_TABLE_NAME\": services.dynamo_db.books_table.table_name}, ) services.api_gateway.create_endpoint(\"GET\", \"/books\", function, public=True) services.dynamo_db.books_table.grant_read_data(function) services.dynamo_db.add_query_permission(services.dynamo_db.books_table, function) In addition to the foundational setup facilitated by Forge, this configuration file plays a crucial role in further customizing our function. It specifically focuses on defining environment variables and granting read permissions to the function for accessing the Books table. Moreover, we leverage a specialized helper method within our DynamoDB class to extend Query permissions to the Lambda function. This distinction is critical as querying entails more specific privileges beyond data reading, ensuring our function has the precise access needed for optimal operation. Launching Our Web Scraper and Data Visualization Endpoint Great, we're all set to deploy our function. Now, we'll commit and push our changes to the remote repository, allowing our CI/CD pipeline to handle the deployment seamlessly. # Add changes to the staging area git add . # Commit the changes with a descriptive message git commit -m \"Deploying Web Scraper and Data Visualization Endpoint\" # Push changes to the 'dev' branch. git push origin dev # Switch to the 'staging' branch, merge changes from 'dev', and push git checkout staging git merge dev git push origin staging # Switch to the 'main' branch, merge changes from 'staging', and push git checkout main git merge staging git push origin main Once the pipeline execution concludes, expect to see a single scraper function established. Additionally, this function will be configured with two distinct triggers: an SNS trigger and an Event Bridge trigger, each serving a unique purpose in the workflow. Now we can also test new endpoints to list the scraped data. Dev: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/books Staging: https://8kwcovaj0f.execute-api.us-east-2.amazonaws.com/staging/books Prod: https://s6zqhu2pg1.execute-api.us-east-2.amazonaws.com/prod/books Congratulations! \ud83c\udf89 You've successfully created your first web scraper using Lambda Layers, SNS, DynamoDB and Event Bridge using Lambda Forge. \ud83d\ude80 Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/articles/json-web-tokens/",
    "title": "JSON Web Tokens - Lambda Forge",
    "content": "JSON Web Tokens - Lambda Forge Skip to content Lambda Forge JSON Web Tokens Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens JSON Web Tokens Table of contents What is JWT? Components of JWT How JWT Authentication Works Benefits of JWT Authentication Conclusion License Table of contents What is JWT? Components of JWT How JWT Authentication Works Benefits of JWT Authentication Conclusion Demystifying JSON Web Tokens (JWT) Authentication: A Comprehensive Guide JWT (JSON Web Token) authentication is a method for securely transmitting information between parties as a JSON object. It is commonly used for implementing stateless authentication mechanisms in web applications. This article provides an overview of JWT authentication, its components, and how it works. What is JWT? JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. It is commonly used for authentication and information exchange in web applications. Components of JWT JWTs consist of three main parts separated by dots (.): Header: Contains metadata about the type of token and the signing algorithm being used. Payload: Contains the claims. Claims are statements about an entity (typically, the user) and additional data. Signature: Used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way. How JWT Authentication Works The client (usually a web browser) sends authentication credentials (such as username and password) to the server. The server verifies the credentials and generates a JWT if they are valid. The server generates a JWT containing user information (claims) and signs it using a secret key. The server sends the JWT back to the client as part of the authentication response (usually in the Authorization header). The client includes the JWT in the Authorization header of subsequent requests to the server. The server verifies the JWT's signature to ensure that it hasn't been tampered with. If the signature is valid, the server extracts the claims from the JWT and authorizes the user. Benefits of JWT Authentication Stateless: JWTs are self-contained, meaning the server does not need to store session state. Scalable: Since JWTs are stateless, they can be easily scaled across multiple servers. Decentralized: JWTs can be generated and verified by different services or systems without centralized coordination. Security: JWTs can be encrypted to provide an additional layer of security. Conclusion JWT authentication is a powerful and widely used method for securing web applications. By using JWTs, developers can implement stateless authentication mechanisms that are scalable, decentralized, and secure. For more information on how to implement JWT authentication in your application, refer to the documentation of your chosen programming language or framework. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/url-shortener/",
    "title": "URL Shortener - Lambda Forge",
    "content": "URL Shortener - Lambda Forge Skip to content Lambda Forge URL Shortener Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener URL Shortener Table of contents Configuring DynamoDB Tables for Each Deployment Stage Incorporating DynamoDB Into the Service Class Implementing the Shortener Function Implementing the Redirect Function Deploying the Functions Testing The Deployment Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Configuring DynamoDB Tables for Each Deployment Stage Incorporating DynamoDB Into the Service Class Implementing the Shortener Function Implementing the Redirect Function Deploying the Functions Testing The Deployment Creating a URL Shortener Service Using DynamoDB In this section, we will explore the development of a URL shortener. This utility enables users to input a lengthy URL, which the system then compresses into a more concise version. Configuring DynamoDB Tables for Each Deployment Stage To ensure our application can operate smoothly across different environments, we'll create three separate DynamoDB tables on AWS DynamoDB console, each tailored for a distinct deployment stage: Dev-URLs, Staging-URLs and Prod-URLs. Note Throughout this tutorial, we'll utilize PK as the Partition Key for all of our DynamoDB tables. Having acquired the ARNs for each stage-specific table, our next step involves integrating these ARNs into the cdk.json file. This crucial configuration enables our Cloud Development Kit (CDK) setup to correctly reference the DynamoDB tables according to the deployment stage. Here's how to update your cdk.json file to include the DynamoDB table ARNs for development, staging, and production environments: cdk.json51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 \"dev\": { \"arns\": { \"urls_table\": \"$DEV-URLS-TABLE-ARN\" } }, \"staging\": { \"arns\": { \"urls_table\": \"$STAGING-URLS-TABLE-ARN\" } }, \"prod\": { \"arns\": { \"urls_table\": \"$PROD-URLS-TABLE-ARN\" } } Incorporating DynamoDB Into the Service Class The subsequent phase in enhancing our application involves integrating the DynamoDB service within our service layer, enabling direct communication with DynamoDB tables. To accomplish this, utilize the following command: forge service dynamo_db This command creates a new service file named dynamo_db.py within the infra/services directory. infra \u251c\u2500\u2500 services \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_gateway.py \u251c\u2500\u2500 aws_lambda.py \u251c\u2500\u2500 dynamo_db.py \u2514\u2500\u2500 layers.py Below is the updated structure of our Service class, now including the DynamoDB service, demonstrating the integration's completion: infra/services/__init__.pyfrom infra.services.dynamo_db import DynamoDB from infra.services.api_gateway import APIGateway from infra.services.aws_lambda import AWSLambda from infra.services.layers import Layers class Services: def __init__(self, scope, context) -> None: self.api_gateway = APIGateway(scope, context) self.aws_lambda = AWSLambda(scope, context) self.layers = Layers(scope) self.dynamo_db = DynamoDB(scope, context) Here is the newly established DynamoDB class: infra/services/dynamo_db.pyfrom aws_cdk import aws_dynamodb as dynamo_db from aws_cdk import aws_iam as iam class DynamoDB: def __init__(self, scope, context: dict) -> None: # self.dynamo = dynamo_db.Table.from_table_arn( # scope, # \"Dynamo\", # context.resources[\"arns\"][\"dynamo_arn\"], # ) ... @staticmethod def add_query_permission(table, function): function.add_to_role_policy( iam.PolicyStatement( actions=[\"dynamodb:Query\"], resources=[f\"{table.table_arn}/index/*\"], ) ) Forge has already laid the groundwork by providing a commented code that outlines the structure for creating a DynamoDB table and retrieving its ARN from the cdk.json file. Additionally, it's worth noting that the DynamoDB class includes a specialized helper method aimed at streamlining the task of assigning query permissions. Let's refine the class variables to directly reference our URLs table. infra/services/dynamo_db.py 5 6 7 8 9 10 11 12class DynamoDB: def __init__(self, scope, context: dict) -> None: self.urls_table = dynamo_db.Table.from_table_arn( scope, \"URLsTable\", context.resources[\"arns\"][\"urls_table\"], ) The context.resources object on line 11 contains only the resources that are pertinent to the current stage. By tapping into this, we can dynamically tweak our AWS resources according to the specific stage we're operating in. Implementing the Shortener Function To initiate, let's develop the shortener function, which serves as the primary interface for user interaction. This function is tasked with accepting a lengthy URL from the user and providing them with its shortened counterpart in response: forge function shortener --method \"POST\" --description \"Creates a new short URL entry in DynamoDB mapped to the original one\" --belongs-to urls --public --no-tests Executing the command will result in the establishment of the following directory structure: functions \u2514\u2500\u2500 urls \u251c\u2500\u2500 shortener \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Now, let's implement it's functionality: functions/urls/shortener/main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43from dataclasses import dataclass import hashlib import json import os import boto3 @dataclass class Input: url: str @dataclass class Output: short_url: str def lambda_handler(event, context): # Retrieve DynamoDB table name and the Base URL from environment variables. URLS_TABLE_NAME = os.environ.get(\"URLS_TABLE_NAME\") BASE_URL = os.environ.get(\"BASE_URL\") # Initialize DynamoDB resource. dynamodb = boto3.resource(\"dynamodb\") # Reference the specified DynamoDB table. urls_table = dynamodb.Table(URLS_TABLE_NAME) # Parse the URL from the incoming event's body. body = json.loads(event[\"body\"]) original_url = body[\"url\"] # Generate a URL hash. hash_object = hashlib.sha256(original_url.encode()) url_id = hash_object.hexdigest()[:6] # Store the mapping in DynamoDB. urls_table.put_item(Item={\"PK\": url_id, \"original_url\": original_url}) # Construct the shortened URL. short_url = f\"{BASE_URL}/{url_id}\" # Return success response. return {\"statusCode\": 200, \"body\": json.dumps({\"short_url\": short_url})} This code is the core of our URL shortening service. It transforms long URLs into shorter, hash-based versions, and storing this information in DynamoDB for future retrieval. Since we are operating in a multi-stage environment, this function is dynamically retrieving the BASE URL from environment variables, as shown on line 20. This approach ensures stage-specific responses, enabling seamless URL customization. To make this possible, we must incorporate the base URL into the cdk.json file and implement minor modifications. These adjustments will enable the base URL to be accessible within the config.py class, thereby allowing the function to access the appropriate base URL depending on the environment it's operating in. cdk.json51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \"dev\": { \"base_url\": \"https://api.lambda-forge.com/dev\", \"arns\": { \"urls_table\": \"$DEV-URLS-TABLE-ARN\" } }, \"staging\": { \"base_url\": \"https://api.lambda-forge.com/staging\", \"arns\": { \"urls_table\": \"$STAGING-URLS-TABLE-ARN\" } }, \"prod\": { \"base_url\": \"https://api.lambda-forge.com\", \"arns\": { \"urls_table\": \"$PROD-URLS-TABLE-ARN\" } } Note Follow the article Finding the Api Gateway Base URL to locate your own base URL in each environment. Initially, the LambdaStack class sends only the self.services as argument to the ShortenerConfig class. We must update it to also send the context parameter. This change allows the config class to access base URLs and dynamically set the correct environment variables during the function definition, enhancing its adaptability. infra/stacks/lambda_stack.py19 20 21 22 23 24 25 26 27class LambdaStack(Stack): def __init__(self, scope: Construct, context, **kwargs) -> None: super().__init__(scope, f\"{context.name}-Lambda-Stack\", **kwargs) self.services = Services(self, context) # Urls ShortenerConfig(self.services, context) To conclude, we will now proceed with configuring our Lambda function. functions/urls/config.pyfrom infra.services import Services class ShortenerConfig: def __init__(self, services: Services, context) -> None: function = services.aws_lambda.create_function( name=\"Shortener\", path=\"./functions/urls\", description=\"Creates a new short URL entry in DynamoDB mapping to the original url\", directory=\"shortener\", environment={ \"URLS_TABLE_NAME\": services.dynamo_db.urls_table.table_name, \"BASE_URL\": context.resources[\"base_url\"], }, ) services.api_gateway.create_endpoint(\"POST\", \"/urls\", function, public=True) services.dynamo_db.urls_table.grant_write_data(function) In this configuration, we specify resources according to the deployment stages of the Lambda function, setting up the DynamoDB table and API Gateway base URL accordingly. It also includes permission settings, enabling the Lambda function to write to our DynamoDB table. Implementing the Redirect Function Having established the necessary components for URL shortening, we now proceed to create a new function tasked with redirecting users from the shortened URL to its original counterpart. Begin by creating a new function: forge function redirect --method \"GET\" --description \"Redirects from the short url to the original url\" --belongs-to urls --public --no-tests The revised directory structure will appear as follows: functions \u2514\u2500\u2500 urls \u251c\u2500\u2500 redirect \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 shortener \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Now, let's implement the redirect functionality. functions/urls/redirect/main.pyfrom dataclasses import dataclass import json import boto3 import os @dataclass class Path: url_id: str @dataclass class Input: pass @dataclass class Output: pass def lambda_handler(event, context): # Retrieve DynamoDB table name from environment variables. URLS_TABLE_NAME = os.environ.get(\"URLS_TABLE_NAME\") # Initialize DynamoDB resource and table reference. dynamodb = boto3.resource(\"dynamodb\") urls_table = dynamodb.Table(URLS_TABLE_NAME) # Extract shortened URL identifier from path parameters. short_url = event[\"pathParameters\"][\"url_id\"] # Retrieve the original URL using the shortened identifier. response = urls_table.get_item(Key={\"PK\": short_url}) original_url = response.get(\"Item\", {}).get(\"original_url\") # Return 404 if no URL is found for the identifier. if original_url is None: return {\"statusCode\": 404, \"body\": json.dumps({\"message\": \"URL not found\"})} # Ensure URL starts with \"http://\" or \"https://\". if not original_url.startswith(\"http\"): original_url = f\"http://{original_url}\" # Redirect to the original URL with a 301 Moved Permanently response. return {\"statusCode\": 301, \"headers\": {\"Location\": original_url}} In this Lambda function, we're essentially setting up a redirect service. When a request comes in with a short URL identifier, the function looks up this identifier in the DynamoDB table to find the corresponding original URL. If found, it redirects the user to the original URL. Next, let's move on to its configuration. functions/urls/redirect/config.pyfrom infra.services import Services class RedirectConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Redirect\", path=\"./functions/urls\", description=\"Redirects from the short url to the original url\", directory=\"redirect\", environment={ \"URLS_TABLE_NAME\": services.dynamo_db.urls_table.table_name, } ) services.api_gateway.create_endpoint(\"GET\", \"/{url_id}\", function, public=True) services.dynamo_db.urls_table.grant_read_data(function) Deploying the Functions Next, we'll commit our code and push it to GitHub, following these steps: # Send your changes to stage git add . # Commit with a descriptive message git commit -m \"URL Shortener with DynamoDB integration\" # Push changes to the 'dev' branch git push origin dev # Merge 'dev' into 'staging' and push git checkout staging git merge dev git push origin staging # Finally, merge 'staging' into 'main' and push git checkout main git merge staging git push origin main This sequence ensures our code passes through development, staging, and finally, production environments, activating our three distinct deployment pipelines. After the pipelines complete, the URL Shortener feature is available across development, staging, and production stages. Testing The Deployment Let's test our URL Shortener by shortening a lengthy URL. For demonstration purposes, we'll use the production environment, but the process remains identical for development and staging, using their respective endpoints. Execute a POST request to shorten the URL: curl --request POST \\ --url https://api.lambda-forge.com/urls \\ --header 'Content-Type: application/json' \\ --header 'accept: application/json' \\ --data '{ \"url\": \"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\" }' This request generates a short URL: { \"short_url\": \"https://api.lambda-forge.com/bc23d3\" } Navigating to this URL in your browser will redirect you to the original content, showcasing our URL Shortener in action. \ud83c\udf89 Success! Our URL shortener function is now deployed and operational across all environments. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/jwt-authentication/",
    "title": "JWT Authentication - Lambda Forge",
    "content": "JWT Authentication - Lambda Forge Skip to content Lambda Forge JWT Authentication Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication JWT Authentication Table of contents Setting Up the DynamoDB Tables Implementing Password Hashing with KMS Creating a JWT Secret on Secrets Manager Using the PYJWT Public Layer Implementing the SignUp Function Implementing the SignIn Functionality Creating the JWT Authorizer Creating a Private Function Deploying the Functions Testing the Functions OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Setting Up the DynamoDB Tables Implementing Password Hashing with KMS Creating a JWT Secret on Secrets Manager Using the PYJWT Public Layer Implementing the SignUp Function Implementing the SignIn Functionality Creating the JWT Authorizer Creating a Private Function Deploying the Functions Testing the Functions Implementing a Serverless Authentication System with JWT, Dynamo DB, Secrets Manager and KMS In this section, we will develop a serverless authentication system using JWT authentication. This system effectively transmits information from the client and authenticates users to gain access to endpoints containing private information. JWT authentication is a secure method for transmitting information between parties as a JSON object. To gain a deeper understanding of JWT tokens and their functionality, you can refer to the article JSON Web Tokens. Setting Up the DynamoDB Tables To get started, we must create tables to store user credentials securely. For maximum decoupling of environments, proceed to your AWS console and create three separate tables, each designated for a specific stage: Dev-Auth, Staging-Auth and Prod-Auth. Once you have obtained the ARNs for these tables, let's integrate them into the cdk.json file within the corresponding environment. cdk.json51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \"dev\": { \"base_url\": \"https://api.lambda-forge.com/dev\", \"arns\": { \"urls_table\": \"$DEV-URLS-TABLE-ARN\", \"images_bucket\": \"$DEV-IMAGES-BUCKET-ARN\", \"auth_table\": \"$DEV-AUTH-TABLE-ARN\" } }, \"staging\": { \"base_url\": \"https://api.lambda-forge.com/staging\", \"arns\": { \"urls_table\": \"$STAGING-URLS-TABLE-ARN\", \"images_bucket\": \"$STAGING-IMAGES-BUCKET-ARN\", \"auth_table\": \"$STAGING-AUTH-TABLE-ARN\" } }, \"prod\": { \"base_url\": \"https://api.lambda-forge.com\", \"arns\": { \"urls_table\": \"$PROD-URLS-TABLE-ARN\", \"images_bucket\": \"$PROD-IMAGES-BUCKET-ARN\", \"auth_table\": \"$PROD-AUTH-TABLE-ARN\" } } Next, we'll create a new variable class within the DynamoDB class to reference our JWT tables. infra/services/dynamo_db.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18class DynamoDB: def __init__(self, scope, context: dict) -> None: self.urls_table = dynamo_db.Table.from_table_arn( scope, \"URLsTable\", context.resources[\"arns\"][\"urls_table\"], ) self.auth_table = dynamo_db.Table.from_table_arn( scope, \"AuthTable\", context.resources[\"arns\"][\"auth_table\"], ) Implementing Password Hashing with KMS As we're dealing with sensitive data such as passwords, storing them in plain text poses a significant security risk. To mitigate this risk, we'll utilize KMS (Key Management Service), an AWS resource designed for hashing passwords and other sensitive information. To create a new KMS service, execute the following command: forge service kms This command creates a new file within the infra/services directory specifically for managing KMS keys. infra \u2514\u2500\u2500 services \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_gateway.py \u251c\u2500\u2500 aws_lambda.py \u251c\u2500\u2500 dynamo_db.py \u251c\u2500\u2500 kms.py \u251c\u2500\u2500 layers.py \u251c\u2500\u2500 s3.py \u2514\u2500\u2500 secrets_manager.py Next, navigate to your AWS KMS console on AWS and create a new key. Then, update the KMS class with the ARN of the newly generated key. infra/services/kms.pyfrom aws_cdk import aws_kms as kms class KMS: def __init__(self, scope, context) -> None: self.auth_key = kms.Key.from_key_arn( scope, \"AuthKey\", key_arn=\"$AUTH-KEY-ARN\", ) Creating a JWT Secret on Secrets Manager To validate JWT tokens securely, a secret is essential. This secret, usually a random string, acts as a key for verifying whether the token was generated from a trusted source. It ensures that only authorized parties can generate and verify tokens, preventing unauthorized access to protected resources. By storing the secret securely, you safeguard the integrity and confidentiality of your authentication system, mitigating the risk of unauthorized access and data breaches. Having that said, navigate to AWS Secrets Manager, create a new secret and save your random string there. After obtaining the secret ARN from AWS Secrets Manager, integrate it into the Secrets Manager class. infra/services/secrets_manager.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17class SecretsManager: def __init__(self, scope, resources) -> None: self.gmail_secret = secrets_manager.Secret.from_secret_complete_arn( scope, id=\"GmailSecret\", secret_complete_arn=\"$GMAIL-SECRET-ARN\", ) self.jwt_secret = secrets_manager.Secret.from_secret_complete_arn( scope, id=\"JwtSecret\", secret_complete_arn=\"$JWT-SECRET-ARN\", ) Using the PYJWT Public Layer To hash our JWT tokens, we'll leverage the widely-used Python library called pyjwt. Due to its popularity, AWS conveniently offers it as a public layer, streamlining our authentication implementation. PYJWT: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-PyJWT:3 Let's now create a new class variable refencing the pyjwt layer. infra/services/layers.py14 15 16 17 18 19 20 21 22 23 24 25 26 self.sm_utils_layer = _lambda.LayerVersion( scope, id='SmUtilsLayer', code=_lambda.Code.from_asset(Path.layer('layers/sm_utils')), compatible_runtimes=[_lambda.Runtime.PYTHON_3_9], description='', ) self.pyjwt_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"JWTLayer\", layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-PyJWT:3\", ) Don't forget to add the pyjwt layer in the requirements.txt requirements.txt15jwt==1.3.1 Implementing the SignUp Function Now that we have all the necessary components set up, it's time to develop our authentication logic. We'll begin with the signup function, which is responsible for receiving an email and a password from the user. This function will then store them in the database, ensuring that the user is unique and storing a hashed version of the password for security purposes. forge function signup --method \"POST\" --description \"Securely handle user registration with unique credentials.\" --public --belongs-to auth --no-tests --endpoint signup This command generates a new function within the auth directory. functions \u2514\u2500\u2500 auth \u251c\u2500\u2500 signup \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py The signup functionality can be implemented as follows: functions/auth/signup/main.pyimport json import os from dataclasses import dataclass import boto3 @dataclass class Input: email: str password: int @dataclass class Output: pass def encrypt_with_kms(plaintext: str, kms_key_id: str) -> str: kms_client = boto3.client(\"kms\") response = kms_client.encrypt(KeyId=kms_key_id, Plaintext=plaintext.encode()) return response[\"CiphertextBlob\"] def lambda_handler(event, context): # Retrieve the DynamoDB table name and KMS key ID from environment variables. AUTH_TABLE_NAME = os.environ.get(\"AUTH_TABLE_NAME\") KMS_KEY_ID = os.environ.get(\"KMS_KEY_ID\") # Initialize a DynamoDB resource. dynamodb = boto3.resource(\"dynamodb\") # Reference the DynamoDB table. auth_table = dynamodb.Table(AUTH_TABLE_NAME) # Parse the request body to get user data. body = json.loads(event[\"body\"]) # Verify if the user already exists. user = auth_table.get_item(Key={\"PK\": body[\"email\"]}) if user.get(\"Item\"): return { \"statusCode\": 400, \"body\": json.dumps({\"message\": \"User already exists\"}), } # Encrypt the password using KMS. encrypted_password = encrypt_with_kms(body[\"password\"], KMS_KEY_ID) # Insert the new user into the DynamoDB table. auth_table.put_item(Item={\"PK\": body[\"email\"], \"password\": encrypted_password}) # Return a successful response with the newly created user ID. return {\"statusCode\": 201} This Lambda function basically handles user signup by encrypting passwords with KMS and storing them in DynamoDB, ensuring secure user registration. With our implementation ready, let's configure it to utilize AWS resources for seamless functionality. functions/auth/signup/config.pyfrom infra.services import Services class SignUpConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"SignUp\", path=\"./functions/auth\", description=\"Securely handle user registration with unique credentials.\", directory=\"signup\", environment={ \"AUTH_TABLE_NAME\": services.dynamo_db.auth_table.table_name, \"KMS_KEY_ID\": services.kms.auth_key.key_id, }, ) services.api_gateway.create_endpoint(\"POST\", \"/signup\", function, public=True) services.dynamo_db.auth_table.grant_read_write_data(function) services.kms.auth_key.grant_encrypt(function) Implementing the SignIn Functionality Now that the signup functionality is in place, let's proceed with the implementation of the signin function. This function will handle user input of email and password, verify them against existing credentials in the database, and decrypt the encrypted password to authenticate the user. forge function signin --method \"POST\" --description \"Authenticate user login by verifying email and password against stored credentials\" --public --belongs-to auth --no-tests --endpoint signin Here's our updated folder structure: functions \u2514\u2500\u2500 auth \u251c\u2500\u2500 signin \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 signup \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py And now, it's implementation. functions/auth/signup/main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69import json import os from dataclasses import dataclass import boto3 import jwt import sm_utils @dataclass class Input: email: str password: str @dataclass class Output: token: str def decrypt_with_kms(ciphertext_blob: bytes, kms_key_id: str) -> str: kms_client = boto3.client(\"kms\") # Then you can pass the decoded string to the decrypt method response = kms_client.decrypt(CiphertextBlob=bytes(ciphertext_blob), KeyId=kms_key_id) return response[\"Plaintext\"].decode() def lambda_handler(event, context): # Retrieve the DynamoDB table name and KMS key ID from environment variables. AUTH_TABLE_NAME = os.environ.get(\"AUTH_TABLE_NAME\") KMS_KEY_ID = os.environ.get(\"KMS_KEY_ID\") JWT_SECRET_NAME = os.environ.get(\"JWT_SECRET_NAME\") JWT_SECRET = sm_utils.get_secret(JWT_SECRET_NAME) # Parse the request body to get user credentials. body = json.loads(event[\"body\"]) email = body[\"email\"] password = body[\"password\"] # Initialize a DynamoDB resource. dynamodb = boto3.resource(\"dynamodb\") auth_table = dynamodb.Table(AUTH_TABLE_NAME) # Retrieve user data from DynamoDB. response = auth_table.get_item(Key={\"PK\": email}) user = response.get(\"Item\") # Check if user exists. if not user: return {\"statusCode\": 401, \"body\": json.dumps({\"error\": \"User not found\"})} # Check if user exists and password matches. encrypted_password = user.get(\"password\") decrypted_password = decrypt_with_kms(encrypted_password, KMS_KEY_ID) # Compare the decrypted password with the provided one. if password == decrypted_password: # Generate JWT token status_code = 200 token = jwt.encode({\"email\": email}, JWT_SECRET, algorithm=\"HS256\") body = json.dumps({\"token\": token}) else: status_code = 401 body = json.dumps({\"error\": \"Invalid credentials\"}) return {\"statusCode\": status_code, \"body\": body} Note that upon matching the input password with the encrypted password, the email is encoded within the JWT token and returned to the client, specifically on line 62. This step is crucial for facilitating retrieval of this information at a later stage. Now, let's move on to configure the signin function. functions/auth/signup/config.pyfrom infra.services import Services class SigninConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Signin\", path=\"./functions/auth\", description=\"Authenticate user login by verifying email and password against stored credentials\", directory=\"signin\", layers=[services.layers.sm_utils_layer, services.layers.pyjwt_layer], environment={ \"AUTH_TABLE_NAME\": services.dynamo_db.auth_table.table_name, \"KMS_KEY_ID\": services.kms.auth_key.key_id, \"JWT_SECRET_NAME\": services.secrets_manager.jwt_secret.secret_name, }, ) services.api_gateway.create_endpoint(\"POST\", \"/signin\", function, public=True) services.dynamo_db.auth_table.grant_read_data(function) services.kms.auth_key.grant_decrypt(function) services.secrets_manager.jwt_secret.grant_read(function) Creating the JWT Authorizer Now that we have the signin function, it returns a token to the client, typically a frontend application, which must include this token in the headers of subsequent requests protected by the JWT authorizer. The authorizer's role is to decode if the token was generated with the same hash as its creation, and if so, decode the token and pass the email to the protected functions. With that being said, let's proceed with its implementation. forge authorizer jwt --description \"A jwt authorizer for private lambda functions\" --no-tests This command creates a new jwt authorizer under the authorizers folder. authorizers \u251c\u2500\u2500 jwt \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Now, let's proceed with the implementation. authorizers/jwt/main.pyimport os import jwt import sm_utils def lambda_handler(event, context): # Extract the JWT token from the event token = event[\"headers\"].get(\"authorization\") # Retrieve the JWT secret from Secrets Manager JWT_SECRET_NAME = os.environ.get(\"JWT_SECRET_NAME\") JWT_SECRET = sm_utils.get_secret(JWT_SECRET_NAME) try: # Decode the JWT token decoded_token = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"]) effect = \"allow\" email = decoded_token.get(\"email\") except: effect = \"deny\" email = None # Set the decoded email as context context = {\"email\": email} # Allow access with the user's email return { \"context\": context, \"policyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"execute-api:Invoke\", \"Effect\": effect, \"Resource\": event[\"methodArn\"], } ], }, } This function attempts to decode the token received in the headers under the key authorization using the same JWT secret stored in Secrets Manager that was used during its generation. If successful, it retrieves the hashed email from the signin function and passes it as context. Now, let's set up our new JWT authorizer. authorizers/jwt/config.pyfrom infra.services import Services class JwtAuthorizerConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"JwtAuthorizer\", path=\"./authorizers/jwt\", description=\"A jwt authorizer for private lambda functions\", layers=[services.layers.sm_utils_layer, services.layers.pyjwt_layer], environment={ \"JWT_SECRET_NAME\": services.secrets_manager.jwt_secret.secret_name }, ) services.api_gateway.create_authorizer(function, name=\"jwt\", default=False) services.secrets_manager.jwt_secret.grant_read(function) Creating a Private Function Now it's time to create a simple private function that can only be acessible through requests that passes the validations made through the authorizer. forge function hello --method \"GET\" --description \"A private function\" --no-tests This command creates a standalone function in the root of the functions folder. functions \u2514\u2500\u2500 hello \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config.py \u2514\u2500\u2500 main.py Now, let's implement a very straightforward function that should simply retrieve the email decoded by the authorizer and return it to the user. functions/hello/main.pyimport json from dataclasses import dataclass @dataclass class Input: pass @dataclass class Output: message: str def lambda_handler(event, context): email = event[\"requestContext\"][\"authorizer\"][\"email\"] return {\"statusCode\": 200, \"body\": json.dumps({\"message\": f\"Hello, {email}!\"})} Finally, it's configuration. functions/hello/config.pyfrom infra.services import Services class HelloConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Hello\", path=\"./functions/hello\", description=\"A private function\", ) services.api_gateway.create_endpoint(\"GET\", \"/hello\", function, authorizer=\"jwt\") Note that because we didn't specify the JWT authorizer as default, and this function isn't marked as public, we need to explicitly pass the authorizer's name to the create_endpoint method. Deploying the Functions Next, we'll commit our code and push it to GitHub, following these steps: # Send your changes to stage git add . # Commit with a descriptive message git commit -m \"JWT Authentication System\" # Push changes to the 'dev' branch git push origin dev # Merge 'dev' into 'staging' and push git checkout staging git merge dev git push origin staging # Finally, merge 'staging' into 'main' and push git checkout main git merge staging git push origin main This sequence ensures our code passes through development, staging, and finally, production environments, activating our three distinct deployment pipelines. After the pipelines complete, the Authentication system should be available across development, staging, and production stages. Testing the Functions Let's start by testing the signup function with the credentials below: Email: tutorial@lambda-forge.com Password: 12345678 curl --request POST \\ --url https://api.lambda-forge.com/signup \\ --header 'Content-Type: application/json' \\ --data '{ \"email\": \"tutorial@lambda-forge.com\", \"password\": \"12345678\" }' The endpoint returns a status code 201. However, if we navigate to the Prod-Auth Table on the Dynamo DB console, we'll notice that the password stored isn't simply 12345678, but rather a significantly lengthy hash string: AQICAHinYrMBzzQKgEowcHc4llDo3C5gg+cRawehAsWTMZ24iwEvX3NrQs9oYi0hD2YnB28hAAAAZjBkBgkqhkiG9w0BBwagVzBVAgEAMFAGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMEeMCuyCVk4C+Nr4OAgEQgCOEKlx01+tGfqKTNXSktApuxUI31EnwzLt7GdW0wdXrT+Yu+A== This showcases the robustness of the security measures in place to safeguard passwords. Now, let's utilize the same credentials to log in: curl --request POST \\ --url https://api.lambda-forge.com/signin \\ --header 'Content-Type: application/json' \\ --data '{ \"email\": \"tutorial@lambdaforge.com\", \"password\": \"12345678\" }' The signin endpoint returns a token: { \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InR1dG9yaWFsQGxhbWJkYWZvcmdlLmNvbSJ9.ppQLiYZ-6AtHdwaCb-H-vJnjTCle9ppULqq5-TqVPjk\" } Next, let's attempt a GET request to the hello function without headers: curl --request GET \\ --url https://api.lambda-forge.com/hello This returns the message: { \"Message\": \"User is not authorized to access this resource with an explicit deny\" } However, if we pass the token generated by the signin function: curl --request GET \\ --url https://api.lambda-forge.com/hello \\ --header 'authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InR1dG9yaWFsQGxhbWJkYWZvcmdlLmNvbSJ9.ppQLiYZ-6AtHdwaCb-H-vJnjTCle9ppULqq5-TqVPjk' We receive the desired output: { \"message\": \"Hello, tutorial@lambda-forge.com!\" } \ud83c\udf89 Congratulations! You've successfully implemented a JWT authentication system, securing your endpoints.\ud83d\udd12 Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/guess-the-number/",
    "title": "Guess The Number - Lambda Forge",
    "content": "Guess The Number - Lambda Forge Skip to content Lambda Forge Guess The Number Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Creating a Guess the Number Game with DynamoDB Coming soon... Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/data-processing-pipeline/",
    "title": "Data Processing Pipeline - Lambda Forge",
    "content": "Data Processing Pipeline - Lambda Forge Skip to content Lambda Forge Data Processing Pipeline Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Data Processing Pipeline for Twitter Streams with Kinesis Firehose, S3 and ElasticSearch Coming soon... Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/",
    "title": "Home - Lambda Forge",
    "content": "Home - Lambda Forge Lambda Forge Home Initializing search Home Docs Example Projects Articles License Lambda Forge Working with Lambdas has never been easier! Get started Find me on Telegram Lambda Forge in Python Available on PIP Telegram Bot Interact with the Lambda Forge bot on Telegram. Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Back to top"
  }
]