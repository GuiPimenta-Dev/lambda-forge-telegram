{
  "url": "https://docs.lambda-forge.com/home/lambda-layers/",
  "title": "Lambda Layers - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nLambda Layers - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              Lambda Layers\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      What Are Lambda Layers?\n    \n\n\n\n\n\n\n      How They Work\n    \n\n\n\n\n\n      Use Cases\n    \n\n\n\n\n\n\n\n\n      AWS Lambda Development with Custom Layers\n    \n\n\n\n\n\n\n      Creating a Custom Layer\n    \n\n\n\n\n\n      Creating a Lambda Function Utilizing the Custom Layer\n    \n\n\n\n\n\n\n\n\n      AWS Lambda Development with External Libraries\n    \n\n\n\n\n\n\n      Incorporating Requests from Public Layers\n    \n\n\n\n\n\n      Creating a Lambda Function Utilizing the Requests Library\n    \n\n\n\n\n\n\n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      What Are Lambda Layers?\n    \n\n\n\n\n\n\n      How They Work\n    \n\n\n\n\n\n      Use Cases\n    \n\n\n\n\n\n\n\n\n      AWS Lambda Development with Custom Layers\n    \n\n\n\n\n\n\n      Creating a Custom Layer\n    \n\n\n\n\n\n      Creating a Lambda Function Utilizing the Custom Layer\n    \n\n\n\n\n\n\n\n\n      AWS Lambda Development with External Libraries\n    \n\n\n\n\n\n\n      Incorporating Requests from Public Layers\n    \n\n\n\n\n\n      Creating a Lambda Function Utilizing the Requests Library\n    \n\n\n\n\n\n\n\n\n\n\n\n\nUtilizing Lambda Layers for Code Reuse and External Library Integration\nWhat Are Lambda Layers?\nLambda Layers are essentially ZIP archives containing libraries, custom runtime environments, or other dependencies. You can include these layers in your Lambda function\u2019s execution environment without having to bundle them directly with your function's deployment package. This means you can use libraries or custom runtimes across multiple Lambda functions without needing to include them in each function\u2019s codebase.\nHow They Work\nWhen you create a Lambda function, you specify which layers to include in its execution environment. During execution, AWS Lambda configures the function's environment to include the content of the specified layers. This content is available to your function's code just as if it were included in the deployment package directly.\nUse Cases\n\nSharing code: Commonly used code can be placed in a layer and shared among multiple functions.\nCustom runtimes: You can use layers to deploy functions in languages that AWS Lambda does not natively support by including the necessary runtime in a layer.\nConfiguration files: Layers can be used to store configuration files that multiple functions need to access.\n\nAWS Lambda Development with Custom Layers\nForge streamlines the process of creating and sharing custom layers across AWS Lambda functions, significantly simplifying code reuse and management. This section walks you through creating a custom layer using Forge, integrating it into your development workflow, and utilizing it within a Lambda function.\nCreating a Custom Layer\nTo begin, execute the following command to create a custom layer named my_custom_layer:\nforge layer --custom my_custom_layer\n\nThis command sets up a specific directory structure for your layer within your project, organizing the code efficiently:\nlayers\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 my_custom_layer\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 my_custom_layer.py\n\nForge not only initializes the necessary structure but also populates my_custom_layer.py with a starter function. This function acts as a blueprint for your shared code:\nlayers/my_custom_layer/my_custom_layer.pydef hello_from_layer():\n    return \"Hello from my_custom_layer layer!\"\n\nAdditionally, Forge sets the new custom layer in the Layers class.\ninfra/services/layers.pyfrom aws_cdk import aws_lambda as _lambda\nfrom lambda_forge import Path\n\n\nclass Layers:\n    def __init__(self, scope) -> None:\n\n        self.my_custom_layer = _lambda.LayerVersion(\n            scope,\n            id='MyCustomLayer',\n            code=_lambda.Code.from_asset(Path.layer('layers/my_custom_layer')),\n            compatible_runtimes=[_lambda.Runtime.PYTHON_3_9],\n            description='',\n         )\n\nTraditionally, working with Lambda layers introduces complexity during development. Since Lambda layers are deployed as zip files and run within the Lambda execution environment, developers usually face challenges in utilizing these layers locally. This often leads to a disconnect between development and production environments, complicating the development process.\nWhen you create a custom layer using Forge, the new layer is automatically integrated into your local virtual environment, similar to installing an external library from pip. However, to ensure that these changes are fully recognized, you may need to reload your IDE or reselect your virtual environment.\n\nNote\nIn case you need to reinstall the custom layers into your virtual environment, use the command:\n\nforge layers --install\n\n\nCreating a Lambda Function Utilizing the Custom Layer\nCreate a new Lambda function that leverages your custom layer by running:\nforge function custom --method \"GET\" --description \"A function that uses my_custom_layer\" --public\n\nThis command simply creates a public function named custom inside the functions directory.\nfunctions\n\u2514\u2500\u2500 custom\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 integration.py\n    \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 unit.py\n\nNow, implement the function to utilize the custom layer:\nfunctions/layers/custom/main.pyimport json\nfrom dataclasses import dataclass\n\nimport my_custom_layer\n\n\n@dataclass\nclass Input:\n    pass\n\n\n@dataclass\nclass Output:\n    message: str\n\n\ndef lambda_handler(event, context):\n\n    message = my_custom_layer.hello_from_layer()\n\n    return {\"statusCode\": 200, \"body\": json.dumps({\"message\": message})}\n\nAlso, update the unit tests to expect the correct output message:\nfunctions/layers/custom/unit.pyimport json\nfrom .main import lambda_handler\n\ndef test_lambda_handler():\n\n    response = lambda_handler(None, None)\n\n    assert response[\"body\"] == json.dumps({\"message\": \"Hello from my_custom_layer layer!\"})\n\nFinally, configure the function to make use of the my_custom_layer layer:\nfunctions/layers/custom/config.pyfrom infra.services import Services\n\n\nclass CustomConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Custom\",\n            path=\"./functions/custom\",\n            description=\"A function to make use of the custom layer\",\n            layers=[services.layers.my_custom_layer],\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/custom\", function, public=True)\n\nOnce you've committed and pushed your code to GitHub and the pipeline has successfully executed, making a GET request to the generated URL should return the following response:\n{\n  \"message\": \"Hello from my_custom_layer layer!\"\n}\n\nThe URL for this tutorial is:\n\nhttps://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/custom\n\nAWS Lambda Development with External Libraries\nIn software development, using external libraries is a common practice to extend functionality and streamline the development process. When working with AWS Lambda, incorporating these external libraries requires integrating them as layers into our Lambda functions.\nTo illustrate this scenario, we will develop a new lambda function aimed to parsing the data retrieved from the external API https://randomuser.me/api/, a public service for generating random fake user data. Since the requests library is not inherently included in Python, it will be necessary to integrate it as a layer in our lambda function.\nIncorporating Requests from Public Layers\nThe requests library is widely used and recognized for its utility. Fortunately, AWS Lambda offers this library as public layers, simplifying the process of integrating them into your projects without the need to create custom layers.\nFor projects utilizing Python 3.9, we can leverage the specific Amazon Resource Names (ARNs) for the requests library made available through Klayers. This provides an efficient way to add these libraries to your Lambda functions. You can explore the complete list of public layers for Python 3.9 in the us-east-2 region here.\nHere is the ARN you'll need:\n\nRequests: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19\n\nLet's proceed by manually incorporating it into our Layers class.\ninfra/services/layers.py 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20        self.my_custom_layer = _lambda.LayerVersion(\n            scope,\n            id='MyCustomLayer',\n            code=_lambda.Code.from_asset(Path.layer('layers/my_custom_layer')),\n            compatible_runtimes=[_lambda.Runtime.PYTHON_3_9],\n            description='',\n         )\n\n        self.requests_layer = _lambda.LayerVersion.from_layer_version_arn(\n            scope,\n            id=\"RequestsLayer\",\n            layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19\",\n        )\n\nAdditionally, include it in the requirements.txt file.\nrequirements.txt16requests==2.28.1\n\nCreating a Lambda Function Utilizing the Requests Library\nTo create a Lambda function that leverages the Requests library, execute the following command:\nforge function external --method \"GET\" --description \"A function that uses an external library\" --public\n\nThis command creates a new function named external inside the functions directory.\nfunctions\n\u2514\u2500\u2500 external\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 integration.py\n    \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 unit.py\n\nNow, implement the function to utilize the custom layer:\nimport json\nfrom dataclasses import dataclass\n\nimport requests\n\n\n@dataclass\nclass Input:\n    pass\n\n\n@dataclass\nclass Name:\n    title: str\n    first: str\n    last: str\n\n\n@dataclass\nclass Output:\n    name: Name\n    gender: str\n    email: str\n\n\ndef lambda_handler(event, context):\n\n    result = requests.get(\"https://randomuser.me/api\").json()[\"results\"][0]\n\n    data = {\n        \"name\": result[\"name\"],\n        \"gender\": result[\"gender\"],\n        \"email\": result[\"email\"],\n    }\n\n    return {\"statusCode\": 200, \"body\": json.dumps({\"data\": data})}\n\nAdditionally, update the unit tests to expect the correct output message:\nfunctions/layers/external/unit.pyimport json\nfrom .main import lambda_handler\n\n\ndef test_lambda_handler():\n\n    response = lambda_handler(None, None)\n    body = json.loads(response[\"body\"])\n\n    assert [\"name\", \"gender\", \"email\"] == list(body.keys())\n\nFinally, configure the function to make use of the requests layer:\nfunctions/layers/custom/config.pyfrom infra.services import Services\n\n\nclass ExternalConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"External\",\n            path=\"./functions/external\",\n            description=\"A function that uses an external library\",\n            layers=[services.layers.requests_layer],\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/external\", function, public=True)\n\nOnce you've committed and pushed your code to GitHub and the pipeline has successfully executed, making a GET request to the generated URL should return the following response:\n{\n  \"name\": {\n    \"title\": \"str\",\n    \"first\": \"str\",\n    \"last\": \"str\"\n  },\n  \"gender\": \"str\",\n  \"email\": \"str\"\n}\n\nFor this tutorial, the generated URL is:\n\nhttps://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/external\n\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}