{
  "url": "https://docs.lambda-forge.com/home/securing-endpoints/",
  "title": "Securing Endpoints - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nSecuring Endpoints - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              Securing Endpoints\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Creating an Authorizer\n    \n\n\n\n\n\n\n      Authorizer Structure\n    \n\n\n\n\n\n      Implementing The Authorizer\n    \n\n\n\n\n\n      Configuring The Authorizer\n    \n\n\n\n\n\n      Adding Authorizer To Lambda Stack\n    \n\n\n\n\n\n\n\n\n      Creating a Private Function\n    \n\n\n\n\n\n\n      Implementing the Function\n    \n\n\n\n\n\n      Configuring the Function as Private\n    \n\n\n\n\n\n\n\n\n      Deployment Process for Both Authorizer and Function\n    \n\n\n\n\n\n      Setting a Default Authorizer\n    \n\n\n\n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Creating an Authorizer\n    \n\n\n\n\n\n\n      Authorizer Structure\n    \n\n\n\n\n\n      Implementing The Authorizer\n    \n\n\n\n\n\n      Configuring The Authorizer\n    \n\n\n\n\n\n      Adding Authorizer To Lambda Stack\n    \n\n\n\n\n\n\n\n\n      Creating a Private Function\n    \n\n\n\n\n\n\n      Implementing the Function\n    \n\n\n\n\n\n      Configuring the Function as Private\n    \n\n\n\n\n\n\n\n\n      Deployment Process for Both Authorizer and Function\n    \n\n\n\n\n\n      Setting a Default Authorizer\n    \n\n\n\n\n\n\n\n\n\nSecuring Endpoints Through an Authorizer\nIn this section, we will delve into securing endpoints by introducing an intermediary function known as an authorizer which will be responsible for validating incoming requests, determining if they should be allowed to access the targeted resources.\nBy implementing an authorizer, you can ensure that only authenticated and authorized requests are processed by your endpoints, enhancing the security and privacy of your application.\nIn fact, Lambda Forge treats all lambda functions as private by default. That's why we had to use the --public flag when creating the previous hello world function, to make it accessible without authentication. Without this flag, we would have been required to implement an authorizer for user authentication.\nCreating an Authorizer\nFirst, let's begin by creating a new authorizer function with the following command:\nforge authorizer secret --description \"An authorizer to validate requests based on a secret present on the headers\"\n\nThis command instructs the forge CLI tool to create a new authorizer under the secret directory.\nAuthorizer Structure\nAuthorizers, while closely resembling Lambda Functions in structure, they fulfill a distinct role.\nLet's examine the structure of an authorizer more closely:\nauthorizers\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 secret\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 unit.py\n\u2514\u2500\u2500 utils\n    \u2514\u2500\u2500 __init__.py\n\n\nauthorizers/ This directory serves as the central hub for all authorizer functions, analogous to how the functions/ directory houses Lambda functions. Each distinct authorizer is allocated its own subdirectory within this folder.\nsecret/ This subdirectory is specifically designed for developing the secret authorizer.\n__init__.py Marks the directory as a Python package, enabling its modules to be imported elsewhere within the project.\nconfig.py Contains the configuration settings for the authorizer, such as environmental variables and access control parameters.\nmain.py Houses the main logic for the authorizer, detailing how incoming requests are verified.\nunit.py Focused on unit testing for the authorizer, these tests ensure that each part of the authorizer's code operates as expected independently.\nutils/ Provides utility functions that are used by the authorizers, offering common functionalities or resources that can be leveraged across various authorizers.\n\nImplementing The Authorizer\nForge automatically generates a basic implementation of an AWS Lambda authorizer that checks for a secret value present on the headers to decide on granting or denying access.\n\nWarning\n The example below is intended solely for demonstration and learning purposes and should not be used in production environemnts. It is crucial to develop a comprehensive and secure authentication mechanism suitable for your application's security needs.\n\nauthorizers/secret/main.pydef lambda_handler(event, context):\n\n    # ATTENTION: The example provided below is strictly for demonstration purposes and should NOT be deployed in a production environment.\n    # It's crucial to develop and integrate your own robust authorization mechanism tailored to your application's security requirements.\n    # To utilize the example authorizer as a temporary placeholder, ensure to include the following header in your requests:\n\n    # Header:\n    # secret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8\n\n    # Remember, security is paramount. This placeholder serves as a guide to help you understand the kind of information your custom authorizer should authenticate.\n    # Please replace it with your secure, proprietary logic before going live. Happy coding!\n\n    secret = event[\"headers\"].get(\"secret\")\n\n    SECRET = \"CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8\"\n    effect = \"allow\" if secret == SECRET else \"deny\"\n\n    policy = {\n        \"policyDocument\": {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"execute-api:Invoke\",\n                    \"Effect\": effect,\n                    \"Resource\": event[\"methodArn\"]\n                }\n            ],\n        },\n    }\n    return policy\n\nThe code snippet above demonstrates that the authorizer is configured to verify the presence of a header named secret in the request, as shown below:\nsecret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8\nThis key serves as a simple form of authentication, granting or denying access based on its presence and accuracy in the request headers.\nThe secret mentioned is automatically generated by Forge, meaning the specific secret you encounter during your implementation will differ from the example provided. Please be mindful of this distinction as you proceed.\nConfiguring The Authorizer\nSimilar to lambda functions in terms of setup, authorizers diverge in their application. Instead of establishing an endpoint on API Gateway, an authorizer is configured to control access to one or more endpoints.\nauthorizers/secret/config.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12from infra.services import Services\n\nclass SecretAuthorizerConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"SecretAuthorizer\",\n            path=\"./authorizers/secret\",\n            description=\"An authorizer to validate requests based on a secret present on the headers\"\n        )\n\n        services.api_gateway.create_authorizer(function, name=\"secret\")\n\nThe configuration detailed above establishes a new authorizer, assigning it a unique identifier secret within the API Gateway.\nAdding Authorizer To Lambda Stack\nSimilarly to the functions, an authorizer needs to be initialized within the LambdaStack class.\nFortunately, Forge takes care of this automatically.\ninfra/stacks/lambda_stack.pyfrom aws_cdk import Stack\nfrom constructs import Construct\nfrom infra.services import Services\nfrom lambda_forge import release\nfrom authorizers.secret.config import SecretAuthorizerConfig\nfrom functions.hello_world.config import HelloWorldConfig\n\n\n@release\nclass LambdaStack(Stack):\n    def __init__(self, scope: Construct, context, **kwargs) -> None:\n\n        super().__init__(scope, f\"{context.name}-Lambda-Stack\", **kwargs)\n\n        self.services = Services(self, context)\n\n        # Authorizers\n        SecretAuthorizerConfig(self.services)\n\n        # HelloWorld\n        HelloWorldConfig(self.services)\n\nCreating a Private Function\nNow let's create a new private function.\nforge function private --method \"GET\" --description \"A private function\"\n\nUpon creating a new function using the Forge CLI, the project's function structure is expanded to include this new function alongside the existing ones.\nfunctions\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 hello_world\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 config.py\n\u2502   \u251c\u2500\u2500 integration.py\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u2514\u2500\u2500 unit.py\n\u2514\u2500\u2500 private\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 config.py\n    \u251c\u2500\u2500 integration.py\n    \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 unit.py\n\nImplementing the Function\nLet's make some adjustments to the response returned by this Lambda function:\nfunctions/private/main.py13\n14\n15\n16\n17\n18def lambda_handler(event, context):\n\n    return {\n        \"statusCode\": 200,\n        \"body\": json.dumps({\"message\": \"Hello From Private!\"})\n    }\n\nRather than displaying the message Hello World!, we will now return Hello From Private!.\nAdditionally, let's revise the unit tests to accurately represent the modifications we've implemented in our code.\nfunctions/private/unit.pyimport json\nfrom .main import lambda_handler\n\ndef test_lambda_handler():\n\n    response = lambda_handler(None, None)\n\n    assert response[\"body\"] == json.dumps({\"message\": \"Hello From Private!\"})\n\nConfiguring the Function as Private\nTo configure the function as private, we must link it to the authorizer by passing the authorizer's name, established during its creation, to the create_endpoint method.\nfunctions/private/config.pyfrom infra.services import Services\n\nclass PrivateConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Private\",\n            path=\"./functions/private\",\n            description=\"A private function\",\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/private\", function, authorizer=\"secret\")\n\nThis configuration file establishes a new private function that is secured with the secrets authorizer and accessible via a GET request at the /private endpoint.\nDeployment Process for Both Authorizer and Function\nAs the next step, let's proceed to upload our updates to GitHub.\n# Add all changes to the staging area\ngit add .\n\n# Commit the staged changes with a clear message\ngit commit -m \"Implemented a private function with an authorizer\"\n\n# Push the committed changes to the 'dev' branch\ngit push origin dev\n\nThis operation will automatically initiate our development pipeline.\n\nAfter the pipeline completes successfully, the private Lambda function becomes operational:\n\nDev: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/private\n\nDirect access to these URLs through a web browser will display an unauthorized access message:\n{\n  \"Message\": \"User is not authorized to access this resource with an explicit deny\"\n}\n\nHowever, access is granted when including the necessary secret in the request header. Below is how to use curl to access the Lambda function:\ncurl --request GET \\\n  --url https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/private \\\n  --header 'secret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8'\n\nUpon running the curl command, you will receive the following response:\n{\n  \"message\": \"Hello From Private!\"\n}\n\nThis validates the functionality of our authorizer, effectively securing the private Lambda function to ensure access is only available to those possessing the correct secret header.\nSetting a Default Authorizer\nLambda Forge automatically considers all functions as private unless specified otherwise. This means functions are generally expected to require an authorizer for access control, unless they are explicitly marked as public.\nTo facilitate easier management and to obviate the need for specifying an authorizer for each Lambda function individually, Lambda Forge allows for the designation of a default authorizer. This default authorizer is automatically applied to all non-public Lambda functions, streamlining the configuration process for securing access.\nTo set an authorizer as the default, you can use the default=True argument in the create_authorizer method when defining your authorizer.\nauthorizers/secret/config.py 6\n 7\n 8\n 9\n10\n11\n12        function = services.aws_lambda.create_function(\n            name=\"SecretAuthorizer\",\n            path=\"./authorizers/secret\",\n            description=\"An authorizer to validate requests based on a secret present on the headers\"\n        )\n\n        services.api_gateway.create_authorizer(function, name=\"secret\", default=True)\n\nNext, we'll update the Private Function configuration to no longer directly associate it with the secrets authorizer.\nfunctions/private/config.py 6\n 7\n 8\n 9\n10\n11\n12        function = services.aws_lambda.create_function(\n            name=\"Private\",\n            path=\"./functions/private\",\n            description=\"A private function\",\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/private\", function)\n\nHaving designated the secretauthorizer as the default, any function not explicitly linked to a particular authorizer and not flagged as public, such as this one, will inherently be protected by the secret authorizer by default.\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}