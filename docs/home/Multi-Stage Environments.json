{
  "url": "https://docs.lambda-forge.com/home/multi-stage-environments/",
  "title": "Multi-Stage Environments - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nMulti-Stage Environments - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              Multi-Stage Environments\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Development Environment\n    \n\n\n\n\n\n\n      Configuring the Development Environment\n    \n\n\n\n\n\n      Development Pipeline Workflow\n    \n\n\n\n\n\n\n\n\n      Staging Environment\n    \n\n\n\n\n\n\n      Configuring the Staging Environment\n    \n\n\n\n\n\n      Deploying the Staging Environment\n    \n\n\n\n\n\n\n\n\n      Production Environment\n    \n\n\n\n\n\n\n      Configuring the Production Environment\n    \n\n\n\n\n\n      Deploying the Production Environment\n    \n\n\n\n\n\n\n\n\n      Overview\n    \n\n\n\n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Development Environment\n    \n\n\n\n\n\n\n      Configuring the Development Environment\n    \n\n\n\n\n\n      Development Pipeline Workflow\n    \n\n\n\n\n\n\n\n\n      Staging Environment\n    \n\n\n\n\n\n\n      Configuring the Staging Environment\n    \n\n\n\n\n\n      Deploying the Staging Environment\n    \n\n\n\n\n\n\n\n\n      Production Environment\n    \n\n\n\n\n\n\n      Configuring the Production Environment\n    \n\n\n\n\n\n      Deploying the Production Environment\n    \n\n\n\n\n\n\n\n\n      Overview\n    \n\n\n\n\n\n\n\n\n\nMulti-Stage Environments With AWS CodePipeline\nIn practical scenarios, it is highly recommended to adopt a multi-stage development approach. This strategy allows you to freely develop and test your code in isolated environments without affecting your live production environment and, consequently, the real-world users of your application.\nIn Lambda Forge, the pipelines for development, staging, and production are meticulously organized within distinct files, found at infra/stacks/dev_stack.py, infra/stacks/staging_stack.py, and infra/stacks/prod_stack.py, respectively.\nEach stage is designed to operate with its own set of isolated resources, to ensure that changes in one environment do not inadvertently affect another.\n\nNote\nLambda Forge provides a suggested pipeline configuration for each stage of deployment. You're encouraged to customize these pipelines to fit your project's needs. Whether adding new steps, adjusting existing ones, reordering or even removing some of them.\n\n\nDevelopment Environment\nThe Development environment is where the initial coding and feature implementation occur, allowing developers to make frequent changes and test new ideas in an isolated environment.\nThis environment is strategically structured to facilitate rapid deployments, allowing new features to be rolled out directly without undergoing any preliminary validation steps. It functions essentially as a sandbox environment, providing developers with a space to both develop and test new features in a fast-paced and flexible setting. This approach enables immediate feedback and iterative improvements, streamlining the development process.\nConfiguring the Development Environment\nThis section details the setup process for the development environment.\ninfra/stacks/dev_stack.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36import aws_cdk as cdk\nfrom aws_cdk import pipelines as pipelines\nfrom aws_cdk.pipelines import CodePipelineSource\nfrom constructs import Construct\nfrom lambda_forge import context\n\nfrom infra.stages.deploy import DeployStage\n\n\n@context(stage=\"Dev\", resources=\"dev\")\nclass DevStack(cdk.Stack):\n    def __init__(self, scope: Construct, context, **kwargs) -> None:\n        super().__init__(scope, f\"{context.stage}-{context.name}-Stack\", **kwargs)\n\n        source = CodePipelineSource.git_hub(\n            f\"{context.repo['owner']}/{context.repo['name']}\", \"dev\"\n        )\n\n        pipeline = pipelines.CodePipeline(\n            self,\n            \"Pipeline\",\n            synth=pipelines.ShellStep(\n                \"Synth\",\n                input=source,\n                install_commands=[\n                    \"pip install lambda-forge aws-cdk-lib\",\n                    \"npm install -g aws-cdk\",\n                ],\n                commands=[\n                    \"cdk synth\",\n                ],\n            ),\n            pipeline_name=f\"{context.stage}-{context.name}-Pipeline\",\n        )\n\n        pipeline.add_stage(DeployStage(self, context))\n\nOn line 10, the context decorator assigns the stage name as Dev and configures the use of resources tagged as dev in the cdk.json file. Moreover, it imports some additional configuration variables from the cdk.json file, assigning them to the argument named context.\ncdk.json41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58    \"region\": \"us-east-2\",\n    \"account\": \"\",\n    \"name\": \"Lambda-Forge-Demo\",\n    \"repo\": {\n      \"owner\": \"$GITHUB-OWNER\",\n      \"name\": \"$GITHUB-REPO\"\n    },\n    \"bucket\": \"\",\n    \"coverage\": 80,\n    \"dev\": {\n        \"arns\": {}\n    },\n    \"staging\": {\n        \"arns\": {}\n    },\n    \"prod\": {\n        \"arns\": {}\n    }\n\nAdditionally, we incorporate the source code from the dev branch hosted on GitHub into the pipeline. Subsequently, we finalize the deployment of the Lambda functions by activating the DeployStage.\nDevelopment Pipeline Workflow\nAs the deployment of the Development Environment has been covered in previous sections, we'll not revisit those steps here. However, the diagram below succinctly illustrates the pipeline configuration established within the AWS CodePipeline.\n\ngraph TD;\n    Source --> Build;\n    Build --> UpdatePipeline[Update Pipeline]\n    UpdatePipeline --> Assets\n    Assets --> Deployment\n\nStaging Environment\nThe Staging environment serves as a near-replica of the production environment, enabling thorough testing and quality assurance processes to catch any bugs or issues before they reach the end-users.\nConfiguring the Staging Environment\nLet's take a deeper look in the staging configuration file.\ninfra/stacks/staging_stack.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56import aws_cdk as cdk\nfrom aws_cdk import pipelines as pipelines\nfrom aws_cdk.pipelines import CodePipelineSource\nfrom constructs import Construct\nfrom lambda_forge import Steps, context\n\nfrom infra.stages.deploy import DeployStage\n\n\n@context(stage=\"Staging\", resources=\"staging\")\nclass StagingStack(cdk.Stack):\n    def __init__(self, scope: Construct, context, **kwargs) -> None:\n        super().__init__(scope, f\"{context.stage}-{context.name}-Stack\", **kwargs)\n\n        source = CodePipelineSource.git_hub(\n            f\"{context.repo['owner']}/{context.repo['name']}\", \"staging\"\n        )\n\n        pipeline = pipelines.CodePipeline(\n            self,\n            \"Pipeline\",\n            synth=pipelines.ShellStep(\n                \"Synth\",\n                input=source,\n                install_commands=[\n                    \"pip install lambda-forge aws-cdk-lib\",\n                    \"npm install -g aws-cdk\",\n                ],\n                commands=[\n                    \"cdk synth\",\n                ],\n            ),\n            pipeline_name=f\"{context.stage}-{context.name}-Pipeline\",\n        )\n\n        steps = Steps(self, context, source)\n\n        # pre\n        unit_tests = steps.run_unit_tests()\n        coverage = steps.run_coverage()\n        validate_docs = steps.validate_docs()\n        validate_integration_tests = steps.validate_integration_tests()\n\n        # post\n        generate_docs = steps.generate_docs()\n        integration_tests = steps.run_integration_tests()\n\n        pipeline.add_stage(\n            DeployStage(self, context),\n            pre=[\n                unit_tests,\n                coverage,\n                validate_integration_tests,\n            ],\n            post=[integration_tests],\n        )\n\nSimilar to the Dev environment, this environment is named Staging, with resources designated as staging in the cdk.json file. We also integrate the source code from the staging branch on GitHub into the pipeline. However, in contrast to Dev, the Staging environment incorporates stringent quality assurance protocols prior to deployment.\nBefore deploying the functions, we execute all unit tests specified in the unit.py files. Additionally, we ensure that the code coverage percentage exceeds the threshold set in the cdk.json file. We also verify that every function connected to the API Gateway is subjected to at least one integration test, identified by the custom pytest.mark.integration decorator.\nOnce all functions have been successfully deployed, we proceed to conduct integration tests as detailed in the integration.py files. Essentially, this procedure entails dispatching an HTTP request to each of the newly deployed functions and ensuring they respond with a 200 status code.\nInitially, the project was initiated with the --no-docs flag, resulting in the validate_docs and generate_docs steps being created but not integrated into the pipeline. We will delve into these steps in greater depth, exploring their functionality and potential benefits in the next section.\nDeploying the Staging Environment\nFirst let's create and push the current code to a new branch called staging.\n# Stage your changes\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"Deploying the Staging Environment\"\n\n# Create/switch to 'staging' branch.\ngit checkout -b staging\n\n# Push 'staging' to remote.\ngit push origin staging\n\nNext, let's deploy the staging environment with CDK, adhering to the naming conventions established by Forge:\ncdk deploy Staging-Lambda-Forge-Demo-Stack\n\nThis command initiates the deployment process. Shortly, AWS CodePipeline will integrate a new pipeline, specifically tailored for the staging environment.\n\nThe pipeline's configuration within AWS CodePipeline is depicted below, showcasing the streamlined workflow from source code to deployment:\n\ngraph TD;\n    Source --> Build;\n    Build --> UpdatePipeline[Update Pipeline]\n    UpdatePipeline --> Assets\n    Assets --> UnitTests[Unit Tests]\n    Assets --> Coverage\n    Assets --> ValidateIntegrationTests[Validate Integration Tests]\n    UnitTests --> Deploy\n    Coverage --> Deploy\n    ValidateIntegrationTests --> Deploy\n    Deploy --> IntegrationTests[Integration Tests]\n\nThe first deployment of the Staging Pipeline often results in failure, a situation that might seem alarming but is actually expected due to the sequence in which components are deployed and tested.\nThis phenomenon occurs because the integration tests are set to execute immediately after the deployment phase. However, during the first deployment, the BASE URL hasn't been established since it's the inaugural setup of the Staging environment. Consequently, this leads to the failure of the Integration_Test phase.\n\nNote that the failure arises after the deployment phase, indicating that the Lambda functions have been successfully deployed.\nTo address this issue, we need to set up the base URL specifically for the integration tests. Follow the guidelines provided in the Retrieving the Api Gateway Base URL article to find your base URL.\nHaving the BASE URL, it must then be incorporated into your cdk.json configuration file under the base_url key. This adjustment ensures that all integration tests can interact with the staging environment seamlessly for automated testing.\ncdk.json48\n49\n50    \"bucket\": \"\",\n    \"coverage\": 80,\n    \"base_url\": \"https://8kwcovaj0f.execute-api.us-east-2.amazonaws.com/staging\"\n\nOnce the base URL is properly configured for the integration tests, commit your changes and push the updated code to GitHub once again. Following these adjustments, the pipeline should successfully complete its run.\nProduction Environment\nThe Production environment represents the phase where the tested and stable version of the software is deployed. This version is accessible to end-users and operates within the live environment. It is imperative that this stage remains the most safeguarded, permitting only fully vetted and secure code to be deployed. This precaution helps in minimizing the risk of exposing end-users to bugs or undesirable functionalities, ensuring a seamless and reliable user experience.\nConfiguring the Production Environment\nimport aws_cdk as cdk\nfrom aws_cdk import pipelines\nfrom aws_cdk.pipelines import CodePipelineSource\nfrom constructs import Construct\nfrom lambda_forge import Steps, context, create_context\n\nfrom infra.stages.deploy import DeployStage\n\n\n@context(\n    stage=\"Prod\",\n    resources=\"prod\",\n    staging=create_context(stage=\"Staging\", resources=\"staging\"),\n)\nclass ProdStack(cdk.Stack):\n    def __init__(self, scope: Construct, context, **kwargs) -> None:\n        super().__init__(scope, f\"{context.stage}-{context.name}-Stack\", **kwargs)\n\n        source = CodePipelineSource.git_hub(\n            f\"{context.repo['owner']}/{context.repo['name']}\", \"main\"\n        )\n\n        pipeline = pipelines.CodePipeline(\n            self,\n            \"Pipeline\",\n            synth=pipelines.ShellStep(\n                \"Synth\",\n                input=source,\n                install_commands=[\n                    \"pip install lambda-forge aws-cdk-lib\",\n                    \"npm install -g aws-cdk\",\n                ],\n                commands=[\n                    \"cdk synth\",\n                ],\n            ),\n            pipeline_name=f\"{context.stage}-{context.name}-Pipeline\",\n        )\n\n        steps = Steps(self, context.staging, source)\n\n        # pre\n        unit_tests = steps.run_unit_tests()\n        coverage = steps.run_coverage()\n        validate_docs = steps.validate_docs()\n        validate_integration_tests = steps.validate_integration_tests()\n\n        # post\n        integration_tests = steps.run_integration_tests()\n\n        pipeline.add_stage(\n            DeployStage(self, context.staging),\n            pre=[\n                unit_tests,\n                coverage,\n                validate_integration_tests,\n            ],\n            post=[integration_tests],\n        )\n\n        # post\n        generate_docs = steps.generate_docs()\n\n        pipeline.add_stage(\n            DeployStage(self, context),\n            post=[],\n        )\n\nThis environment is named Prod and the resources used are provenient from the prod key in the cdk.json file. Additionally, the main branch on GitHub is being used to trigger the pipeline.\nGiven the critical need for security and integrity in production, we replicate the staging environment, applying all tests and safeguards again before deploying the production stage. This ensures that any changes meet our high quality standards before production deployment, effectively protecting against vulnerabilities and ensuring a stable user experience.\nDeploying the Production Environment\nFirstly, commit and push your code to a new branch named main on GitHub\n# Stage your changes\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"Deploying the Production Environment\"\n\n# Create/switch to 'main' branch.\ngit checkout -b main\n\n# Push 'main' to remote.\ngit push origin main\n\nFollowing the branch setup, deploy your staging environment using the AWS CDK, adhering to the naming conventions provided by Forge.\ncdk deploy Prod-Lambda-Forge-Demo-Stack\n\nExecuting this command initiates the creation of a new pipeline in AWS CodePipeline, designed to automate your deployment process.\n\nThe following diagram visually represents the configuration established in AWS CodePipeline.\n\ngraph TD;\n    Source --> Build;\n    Build --> UpdatePipeline[Update Pipeline]\n    UpdatePipeline --> Assets\n    Assets --> UnitTests[Unit Tests]\n    Assets --> Coverage\n    Assets --> ValidateIntegrationTests[Validate Integration Tests]\n    UnitTests --> DeployStaging[Deploy Staging]\n    Coverage --> DeployStaging\n    ValidateIntegrationTests --> DeployStaging\n    DeployStaging --> IntegrationTests[Integration Tests]\n    IntegrationTests --> DeployProduction[Deploy Production]\n\nUpon the successful completion of the pipeline execution, you'll be able to observe a new Lambda function ready and deployed within your AWS Lambda console\n\nTo verify the url created, navigate to the newly deployed Lambda function in the AWS Lambda console. Within the function, proceed to Configurations -> Triggers. Here, you'll find the URL for the new endpoint that has been activated as part of the deployment process.\nFor this tutorial, the endpoint URL provided is:\n\nhttps://s6zqhu2pg1.execute-api.us-east-2.amazonaws.com/prod/hello_world\n\nOverview\nBy adhering to the instructions outlined in this tutorial, you are now equipped with three distinct CI/CD pipelines. Each pipeline corresponds to a specific stage of the development lifecycle, directly linked to the dev, staging, and main branches in your GitHub repository.\nThese pipelines ensure that changes made in each branch are automatically integrated and deployed to the appropriate environment, streamlining the process from development through to production.\n\nFurthermore, you have deployed three unique functions, each corresponding to a different environment:\n\nDev: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/hello_world\nStaging: https://8kwcovaj0f.execute-api.us-east-2.amazonaws.com/staging/hello_world\nProd: https://s6zqhu2pg1.execute-api.us-east-2.amazonaws.com/prod/hello_world\n\nEach link directs you to the corresponding function deployed within its respective environment, demonstrating the successful separation and management of development, staging, and production stages through your CI/CD workflows.\nCongratulations! \ud83c\udf89 You've successfully deployed your Lambda function across three different environments using Lambda Forge! \ud83d\ude80\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}