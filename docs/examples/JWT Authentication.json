{
  "url": "https://docs.lambda-forge.com/examples/jwt-authentication/",
  "title": "JWT Authentication - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nJWT Authentication - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              JWT Authentication\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Setting Up the DynamoDB Tables\n    \n\n\n\n\n\n      Implementing Password Hashing with KMS\n    \n\n\n\n\n\n      Creating a JWT Secret on Secrets Manager\n    \n\n\n\n\n\n      Using the PYJWT Public Layer\n    \n\n\n\n\n\n      Implementing the SignUp Function\n    \n\n\n\n\n\n      Implementing the SignIn Functionality\n    \n\n\n\n\n\n      Creating the JWT Authorizer\n    \n\n\n\n\n\n      Creating a Private Function\n    \n\n\n\n\n\n      Deploying the Functions\n    \n\n\n\n\n\n      Testing the Functions\n    \n\n\n\n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Setting Up the DynamoDB Tables\n    \n\n\n\n\n\n      Implementing Password Hashing with KMS\n    \n\n\n\n\n\n      Creating a JWT Secret on Secrets Manager\n    \n\n\n\n\n\n      Using the PYJWT Public Layer\n    \n\n\n\n\n\n      Implementing the SignUp Function\n    \n\n\n\n\n\n      Implementing the SignIn Functionality\n    \n\n\n\n\n\n      Creating the JWT Authorizer\n    \n\n\n\n\n\n      Creating a Private Function\n    \n\n\n\n\n\n      Deploying the Functions\n    \n\n\n\n\n\n      Testing the Functions\n    \n\n\n\n\n\n\n\n\n\nImplementing a Serverless Authentication System with JWT, Dynamo DB, Secrets Manager and KMS\nIn this section, we will develop a serverless authentication system using JWT authentication. This system effectively transmits information from the client and authenticates users to gain access to endpoints containing private information.\nJWT authentication is a secure method for transmitting information between parties as a JSON object. To gain a deeper understanding of JWT tokens and their functionality, you can refer to the article JSON Web Tokens.\nSetting Up the DynamoDB Tables\nTo get started, we must create tables to store user credentials securely. For maximum decoupling of environments, proceed to your AWS console and create three separate tables, each designated for a specific stage: Dev-Auth, Staging-Auth and Prod-Auth.\nOnce you have obtained the ARNs for these tables, let's integrate them into the cdk.json file within the corresponding environment.\ncdk.json51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74   \"dev\": {\n      \"base_url\": \"https://api.lambda-forge.com/dev\",\n      \"arns\": {\n        \"urls_table\": \"$DEV-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$DEV-IMAGES-BUCKET-ARN\",\n        \"auth_table\": \"$DEV-AUTH-TABLE-ARN\"\n      }\n    },\n    \"staging\": {\n      \"base_url\": \"https://api.lambda-forge.com/staging\",\n      \"arns\": {\n        \"urls_table\": \"$STAGING-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$STAGING-IMAGES-BUCKET-ARN\",\n        \"auth_table\": \"$STAGING-AUTH-TABLE-ARN\"\n      }\n    },\n    \"prod\": {\n      \"base_url\": \"https://api.lambda-forge.com\",\n      \"arns\": {\n        \"urls_table\": \"$PROD-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$PROD-IMAGES-BUCKET-ARN\",\n        \"auth_table\": \"$PROD-AUTH-TABLE-ARN\"\n      }\n    }\n\nNext, we'll create a new variable class within the DynamoDB class to reference our JWT tables.\ninfra/services/dynamo_db.py 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18class DynamoDB:\n    def __init__(self, scope, context: dict) -> None:\n\n        self.urls_table = dynamo_db.Table.from_table_arn(\n            scope,\n            \"URLsTable\",\n            context.resources[\"arns\"][\"urls_table\"],\n        )\n\n        self.auth_table = dynamo_db.Table.from_table_arn(\n            scope,\n            \"AuthTable\",\n            context.resources[\"arns\"][\"auth_table\"],\n        )\n\nImplementing Password Hashing with KMS\nAs we're dealing with sensitive data such as passwords, storing them in plain text poses a significant security risk. To mitigate this risk, we'll utilize KMS (Key Management Service), an AWS resource designed for hashing passwords and other sensitive information.\nTo create a new KMS service, execute the following command:\nforge service kms\n\nThis command creates a new file within the infra/services directory specifically for managing KMS keys.\ninfra\n\u2514\u2500\u2500 services\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api_gateway.py\n    \u251c\u2500\u2500 aws_lambda.py\n    \u251c\u2500\u2500 dynamo_db.py\n    \u251c\u2500\u2500 kms.py\n    \u251c\u2500\u2500 layers.py\n    \u251c\u2500\u2500 s3.py\n    \u2514\u2500\u2500 secrets_manager.py\n\nNext, navigate to your AWS KMS console on AWS and create a new key. Then, update the KMS class with the ARN of the newly generated key.\ninfra/services/kms.pyfrom aws_cdk import aws_kms as kms\n\n\nclass KMS:\n    def __init__(self, scope, context) -> None:\n\n        self.auth_key = kms.Key.from_key_arn(\n            scope,\n            \"AuthKey\",\n            key_arn=\"$AUTH-KEY-ARN\",\n        )\n\nCreating a JWT Secret on Secrets Manager\nTo validate JWT tokens securely, a secret is essential. This secret, usually a random string, acts as a key for verifying whether the token was generated from a trusted source. It ensures that only authorized parties can generate and verify tokens, preventing unauthorized access to protected resources.\nBy storing the secret securely, you safeguard the integrity and confidentiality of your authentication system, mitigating the risk of unauthorized access and data breaches. Having that said, navigate to AWS Secrets Manager, create a new secret and save your random string there.\nAfter obtaining the secret ARN from AWS Secrets Manager, integrate it into the Secrets Manager class.\ninfra/services/secrets_manager.py 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17class SecretsManager:\n    def __init__(self, scope, resources) -> None:\n\n        self.gmail_secret = secrets_manager.Secret.from_secret_complete_arn(\n            scope,\n            id=\"GmailSecret\",\n            secret_complete_arn=\"$GMAIL-SECRET-ARN\",\n        )\n\n        self.jwt_secret = secrets_manager.Secret.from_secret_complete_arn(\n            scope,\n            id=\"JwtSecret\",\n            secret_complete_arn=\"$JWT-SECRET-ARN\",\n        )\n\nUsing the PYJWT Public Layer\nTo hash our JWT tokens, we'll leverage the widely-used Python library called pyjwt. Due to its popularity, AWS conveniently offers it as a public layer, streamlining our authentication implementation.\n\nPYJWT: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-PyJWT:3\n\nLet's now create a new class variable refencing the pyjwt layer.\ninfra/services/layers.py14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26        self.sm_utils_layer = _lambda.LayerVersion(\n            scope,\n            id='SmUtilsLayer',\n            code=_lambda.Code.from_asset(Path.layer('layers/sm_utils')),\n            compatible_runtimes=[_lambda.Runtime.PYTHON_3_9],\n            description='',\n         )\n\n        self.pyjwt_layer = _lambda.LayerVersion.from_layer_version_arn(\n            scope,\n            id=\"JWTLayer\",\n            layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-PyJWT:3\",\n        )\n\nDon't forget to add the pyjwt layer in the requirements.txt\nrequirements.txt15jwt==1.3.1\n\nImplementing the SignUp Function\nNow that we have all the necessary components set up, it's time to develop our authentication logic. We'll begin with the signup function, which is responsible for receiving an email and a password from the user. This function will then store them in the database, ensuring that the user is unique and storing a hashed version of the password for security purposes.\nforge function signup --method \"POST\" --description \"Securely handle user registration with unique credentials.\" --public --belongs-to auth --no-tests --endpoint signup\n\nThis command generates a new function within the auth directory.\nfunctions\n\u2514\u2500\u2500 auth\n    \u251c\u2500\u2500 signup\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nThe signup functionality can be implemented as follows:\nfunctions/auth/signup/main.pyimport json\nimport os\nfrom dataclasses import dataclass\n\nimport boto3\n\n\n@dataclass\nclass Input:\n    email: str\n    password: int\n\n\n@dataclass\nclass Output:\n    pass\n\n\ndef encrypt_with_kms(plaintext: str, kms_key_id: str) -> str:\n    kms_client = boto3.client(\"kms\")\n    response = kms_client.encrypt(KeyId=kms_key_id, Plaintext=plaintext.encode())\n    return response[\"CiphertextBlob\"]\n\n\ndef lambda_handler(event, context):\n    # Retrieve the DynamoDB table name and KMS key ID from environment variables.\n    AUTH_TABLE_NAME = os.environ.get(\"AUTH_TABLE_NAME\")\n    KMS_KEY_ID = os.environ.get(\"KMS_KEY_ID\")\n\n    # Initialize a DynamoDB resource.\n    dynamodb = boto3.resource(\"dynamodb\")\n\n    # Reference the DynamoDB table.\n    auth_table = dynamodb.Table(AUTH_TABLE_NAME)\n\n    # Parse the request body to get user data.\n    body = json.loads(event[\"body\"])\n\n    # Verify if the user already exists.\n    user = auth_table.get_item(Key={\"PK\": body[\"email\"]})\n    if user.get(\"Item\"):\n        return {\n            \"statusCode\": 400,\n            \"body\": json.dumps({\"message\": \"User already exists\"}),\n        }\n\n    # Encrypt the password using KMS.\n    encrypted_password = encrypt_with_kms(body[\"password\"], KMS_KEY_ID)\n\n    # Insert the new user into the DynamoDB table.\n    auth_table.put_item(Item={\"PK\": body[\"email\"], \"password\": encrypted_password})\n\n    # Return a successful response with the newly created user ID.\n    return {\"statusCode\": 201}\n\nThis Lambda function basically handles user signup by encrypting passwords with KMS and storing them in DynamoDB, ensuring secure user registration.\nWith our implementation ready, let's configure it to utilize AWS resources for seamless functionality.\nfunctions/auth/signup/config.pyfrom infra.services import Services\n\n\nclass SignUpConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"SignUp\",\n            path=\"./functions/auth\",\n            description=\"Securely handle user registration with unique credentials.\",\n            directory=\"signup\",\n            environment={\n                \"AUTH_TABLE_NAME\": services.dynamo_db.auth_table.table_name,\n                \"KMS_KEY_ID\": services.kms.auth_key.key_id,\n            },\n        )\n\n        services.api_gateway.create_endpoint(\"POST\", \"/signup\", function, public=True)\n\n        services.dynamo_db.auth_table.grant_read_write_data(function)\n\n        services.kms.auth_key.grant_encrypt(function)\n\nImplementing the SignIn Functionality\nNow that the signup functionality is in place, let's proceed with the implementation of the signin function. This function will handle user input of email and password, verify them against existing credentials in the database, and decrypt the encrypted password to authenticate the user.\nforge function signin --method \"POST\" --description \"Authenticate user login by verifying email and password against stored credentials\" --public --belongs-to auth --no-tests --endpoint signin\n\nHere's our updated folder structure:\nfunctions\n\u2514\u2500\u2500 auth\n    \u251c\u2500\u2500 signin\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u251c\u2500\u2500 signup\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nAnd now, it's implementation.\nfunctions/auth/signup/main.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69import json\nimport os\nfrom dataclasses import dataclass\n\nimport boto3\nimport jwt\nimport sm_utils\n\n\n@dataclass\nclass Input:\n    email: str\n    password: str\n\n\n@dataclass\nclass Output:\n    token: str\n\n\ndef decrypt_with_kms(ciphertext_blob: bytes, kms_key_id: str) -> str:\n    kms_client = boto3.client(\"kms\")\n\n    # Then you can pass the decoded string to the decrypt method\n    response = kms_client.decrypt(CiphertextBlob=bytes(ciphertext_blob), KeyId=kms_key_id)\n    return response[\"Plaintext\"].decode()\n\n\ndef lambda_handler(event, context):\n    # Retrieve the DynamoDB table name and KMS key ID from environment variables.\n    AUTH_TABLE_NAME = os.environ.get(\"AUTH_TABLE_NAME\")\n    KMS_KEY_ID = os.environ.get(\"KMS_KEY_ID\")\n    JWT_SECRET_NAME = os.environ.get(\"JWT_SECRET_NAME\")\n\n    JWT_SECRET = sm_utils.get_secret(JWT_SECRET_NAME)\n\n    # Parse the request body to get user credentials.\n    body = json.loads(event[\"body\"])\n    email = body[\"email\"]\n    password = body[\"password\"]\n\n    # Initialize a DynamoDB resource.\n    dynamodb = boto3.resource(\"dynamodb\")\n    auth_table = dynamodb.Table(AUTH_TABLE_NAME)\n\n    # Retrieve user data from DynamoDB.\n    response = auth_table.get_item(Key={\"PK\": email})\n    user = response.get(\"Item\")\n\n    # Check if user exists.\n    if not user:\n        return {\"statusCode\": 401, \"body\": json.dumps({\"error\": \"User not found\"})}\n\n    # Check if user exists and password matches.\n    encrypted_password = user.get(\"password\")\n    decrypted_password = decrypt_with_kms(encrypted_password, KMS_KEY_ID)\n\n    # Compare the decrypted password with the provided one.\n    if password == decrypted_password:\n        # Generate JWT token\n        status_code = 200\n        token = jwt.encode({\"email\": email}, JWT_SECRET, algorithm=\"HS256\")\n        body = json.dumps({\"token\": token})\n\n    else:\n        status_code = 401\n        body = json.dumps({\"error\": \"Invalid credentials\"})\n\n    return {\"statusCode\": status_code, \"body\": body}\n\nNote that upon matching the input password with the encrypted password, the email is encoded within the JWT token and returned to the client, specifically on line 62. This step is crucial for facilitating retrieval of this information at a later stage.\nNow, let's move on to configure the signin function.\nfunctions/auth/signup/config.pyfrom infra.services import Services\n\n\nclass SigninConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Signin\",\n            path=\"./functions/auth\",\n            description=\"Authenticate user login by verifying email and password against stored credentials\",\n            directory=\"signin\",\n            layers=[services.layers.sm_utils_layer, services.layers.pyjwt_layer],\n            environment={\n                \"AUTH_TABLE_NAME\": services.dynamo_db.auth_table.table_name,\n                \"KMS_KEY_ID\": services.kms.auth_key.key_id,\n                \"JWT_SECRET_NAME\": services.secrets_manager.jwt_secret.secret_name,\n            },\n        )\n\n        services.api_gateway.create_endpoint(\"POST\", \"/signin\", function, public=True)\n\n        services.dynamo_db.auth_table.grant_read_data(function)\n\n        services.kms.auth_key.grant_decrypt(function)\n\n        services.secrets_manager.jwt_secret.grant_read(function)\n\nCreating the JWT Authorizer\nNow that we have the signin function, it returns a token to the client, typically a frontend application, which must include this token in the headers of subsequent requests protected by the JWT authorizer. The authorizer's role is to decode if the token was generated with the same hash as its creation, and if so, decode the token and pass the email to the protected functions.\nWith that being said, let's proceed with its implementation.\nforge authorizer jwt --description \"A jwt authorizer for private lambda functions\" --no-tests\n\nThis command creates a new jwt authorizer under the authorizers folder.\nauthorizers\n  \u251c\u2500\u2500 jwt\n  \u2502   \u251c\u2500\u2500 __init__.py\n  \u2502   \u251c\u2500\u2500 config.py\n  \u2502   \u2514\u2500\u2500 main.py\n  \u2514\u2500\u2500 utils\n      \u2514\u2500\u2500 __init__.py\n\nNow, let's proceed with the implementation.\nauthorizers/jwt/main.pyimport os\nimport jwt\nimport sm_utils\n\ndef lambda_handler(event, context):\n\n    # Extract the JWT token from the event\n    token = event[\"headers\"].get(\"authorization\")\n\n    # Retrieve the JWT secret from Secrets Manager\n    JWT_SECRET_NAME = os.environ.get(\"JWT_SECRET_NAME\")\n    JWT_SECRET = sm_utils.get_secret(JWT_SECRET_NAME)\n\n    try:\n        # Decode the JWT token\n        decoded_token = jwt.decode(token, JWT_SECRET, algorithms=[\"HS256\"])\n        effect = \"allow\"\n        email = decoded_token.get(\"email\")\n    except:\n        effect = \"deny\"\n        email = None\n\n    # Set the decoded email as context\n    context = {\"email\": email}\n\n    # Allow access with the user's email\n    return {\n        \"context\": context,\n        \"policyDocument\": {\n            \"Version\": \"2012-10-17\",\n            \"Statement\": [\n                {\n                    \"Action\": \"execute-api:Invoke\",\n                    \"Effect\": effect,\n                    \"Resource\": event[\"methodArn\"],\n                }\n            ],\n        },\n    }\n\nThis function attempts to decode the token received in the headers under the key authorization using the same JWT secret stored in Secrets Manager that was used during its generation. If successful, it retrieves the hashed email from the signin function and passes it as context.\nNow, let's set up our new JWT authorizer.\nauthorizers/jwt/config.pyfrom infra.services import Services\n\n\nclass JwtAuthorizerConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"JwtAuthorizer\",\n            path=\"./authorizers/jwt\",\n            description=\"A jwt authorizer for private lambda functions\",\n            layers=[services.layers.sm_utils_layer, services.layers.pyjwt_layer],\n            environment={\n                \"JWT_SECRET_NAME\": services.secrets_manager.jwt_secret.secret_name\n            },\n        )\n\n        services.api_gateway.create_authorizer(function, name=\"jwt\", default=False)\n\n        services.secrets_manager.jwt_secret.grant_read(function)\n\nCreating a Private Function\nNow it's time to create a simple private function that can only be acessible through requests that passes the validations made through the authorizer.\nforge function hello --method \"GET\" --description \"A private function\" --no-tests\n\nThis command creates a standalone function in the root of the functions folder.\nfunctions\n\u2514\u2500\u2500 hello\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 config.py\n    \u2514\u2500\u2500 main.py\n\nNow, let's implement a very straightforward function that should simply retrieve the email decoded by the authorizer and return it to the user.\nfunctions/hello/main.pyimport json\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Input:\n    pass\n\n\n@dataclass\nclass Output:\n    message: str\n\n\ndef lambda_handler(event, context):\n\n    email = event[\"requestContext\"][\"authorizer\"][\"email\"]\n\n    return {\"statusCode\": 200, \"body\": json.dumps({\"message\": f\"Hello, {email}!\"})}\n\nFinally, it's configuration.\nfunctions/hello/config.pyfrom infra.services import Services\n\n\nclass HelloConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Hello\",\n            path=\"./functions/hello\",\n            description=\"A private function\",\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/hello\", function, authorizer=\"jwt\")\n\nNote that because we didn't specify the JWT authorizer as default, and this function isn't marked as public, we need to explicitly pass the authorizer's name to the create_endpoint method.\nDeploying the Functions\nNext, we'll commit our code and push it to GitHub, following these steps:\n# Send your changes to stage\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"JWT Authentication System\"\n\n# Push changes to the 'dev' branch\ngit push origin dev\n\n# Merge 'dev' into 'staging' and push\ngit checkout staging\ngit merge dev\ngit push origin staging\n\n# Finally, merge 'staging' into 'main' and push\ngit checkout main\ngit merge staging\ngit push origin main\n\nThis sequence ensures our code passes through development, staging, and finally, production environments, activating our three distinct deployment pipelines.\n\nAfter the pipelines complete, the Authentication system should be available across development, staging, and production stages.\nTesting the Functions\nLet's start by testing the signup function with the credentials below:\n\nEmail: tutorial@lambda-forge.com\nPassword: 12345678\n\ncurl --request POST \\\n  --url https://api.lambda-forge.com/signup \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"email\": \"tutorial@lambda-forge.com\",\n    \"password\": \"12345678\"\n}'\n\nThe endpoint returns a status code 201.\nHowever, if we navigate to the Prod-Auth Table on the Dynamo DB console, we'll notice that the password stored isn't simply 12345678, but rather a significantly lengthy hash string:\nAQICAHinYrMBzzQKgEowcHc4llDo3C5gg+cRawehAsWTMZ24iwEvX3NrQs9oYi0hD2YnB28hAAAAZjBkBgkqhkiG9w0BBwagVzBVAgEAMFAGCSqGSIb3DQEHATAeBglghkgBZQMEAS4wEQQMEeMCuyCVk4C+Nr4OAgEQgCOEKlx01+tGfqKTNXSktApuxUI31EnwzLt7GdW0wdXrT+Yu+A==\n\nThis showcases the robustness of the security measures in place to safeguard passwords.\nNow, let's utilize the same credentials to log in:\ncurl --request POST \\\n  --url https://api.lambda-forge.com/signin \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"email\": \"tutorial@lambdaforge.com\",\n    \"password\": \"12345678\"\n}'\n\nThe signin endpoint returns a token:\n{\n  \"token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InR1dG9yaWFsQGxhbWJkYWZvcmdlLmNvbSJ9.ppQLiYZ-6AtHdwaCb-H-vJnjTCle9ppULqq5-TqVPjk\"\n}\n\nNext, let's attempt a GET request to the hello function without headers:\ncurl --request GET \\\n  --url https://api.lambda-forge.com/hello\n\nThis returns the message:\n{\n  \"Message\": \"User is not authorized to access this resource with an explicit deny\"\n}\n\nHowever, if we pass the token generated by the signin function:\ncurl --request GET \\\n  --url https://api.lambda-forge.com/hello \\\n  --header 'authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InR1dG9yaWFsQGxhbWJkYWZvcmdlLmNvbSJ9.ppQLiYZ-6AtHdwaCb-H-vJnjTCle9ppULqq5-TqVPjk'\n\nWe receive the desired output:\n{\n  \"message\": \"Hello, tutorial@lambda-forge.com!\"\n}\n\n\ud83c\udf89 Congratulations! You've successfully implemented a JWT authentication system, securing your endpoints.\ud83d\udd12\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}