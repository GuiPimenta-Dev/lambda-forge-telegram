{
  "url": "https://docs.lambda-forge.com/examples/image-to-qr-code-converter/",
  "title": "Image to QR Code Converter - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nImage to QR Code Converter - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              Image to QR Code Converter\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Incorporating S3 Into the Service Class\n    \n\n\n\n\n\n      Incorporating Secrets Manager into the Services Class\n    \n\n\n\n\n\n      Using a Non-Public Library as Lambda Layer\n    \n\n\n\n\n\n      Implementing the Function to Convert Image to QR Code\n    \n\n\n\n\n\n      Implementing the Mailer Function\n    \n\n\n\n\n\n      Mitigating Security Risks in Mailer Configuration\n    \n\n\n\n\n\n\n      Creating a Custom Layer to Avoid Code Duplication\n    \n\n\n\n\n\n      Refactoring The Mailer Function to Use Custom Layers\n    \n\n\n\n\n\n\n\n\n      Deploying The Functions\n    \n\n\n\n\n\n      Testing the Image to QR Code Conversion\n    \n\n\n\n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Incorporating S3 Into the Service Class\n    \n\n\n\n\n\n      Incorporating Secrets Manager into the Services Class\n    \n\n\n\n\n\n      Using a Non-Public Library as Lambda Layer\n    \n\n\n\n\n\n      Implementing the Function to Convert Image to QR Code\n    \n\n\n\n\n\n      Implementing the Mailer Function\n    \n\n\n\n\n\n      Mitigating Security Risks in Mailer Configuration\n    \n\n\n\n\n\n\n      Creating a Custom Layer to Avoid Code Duplication\n    \n\n\n\n\n\n      Refactoring The Mailer Function to Use Custom Layers\n    \n\n\n\n\n\n\n\n\n      Deploying The Functions\n    \n\n\n\n\n\n      Testing the Image to QR Code Conversion\n    \n\n\n\n\n\n\n\n\n\nConverting Image to QR Code with AWS S3, Secrets Manager and Email Notifications\nIn this part, we're going to cover how to make a function that turns images uploaded by users into QR codes. When a user sends a request, the image gets processed, saved on Amazon S3, and then sent to them via email so they can easily check out the results.\nIncorporating S3 Into the Service Class\nLet's start creating three distinct buckets, each dedicated to a specific stage: Dev-Lambda-Forge-Images, Staging-Lambda-Forge-Images and Prod-Lambda-Forge-Images.\n\nNote\nKeep in mind that your bucket name must be unique across all AWS regions. Therefore, you'll need to select distinct names for your project.\n\nNow place the arns on your cdk.json.\ncdk.json51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71   \"dev\": {\n      \"base_url\": \"https://api.lambda-forge.com/dev\",\n      \"arns\": {\n        \"urls_table\": \"$DEV-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$DEV-IMAGES-BUCKET-ARN\"\n      }\n    },\n    \"staging\": {\n      \"base_url\": \"https://api.lambda-forge.com/staging\",\n      \"arns\": {\n        \"urls_table\": \"$STAGING-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$STAGING-IMAGES-BUCKET-ARN\"\n      }\n    },\n    \"prod\": {\n      \"base_url\": \"https://api.lambda-forge.com\",\n      \"arns\": {\n        \"urls_table\": \"$PROD-URLS-TABLE-ARN\",\n        \"images_bucket\": \"$PROD-IMAGES-BUCKET-ARN\"\n      }\n    }\n\nThe next step involves integrating the S3 service into our service layer, facilitating direct communication with S3 buckets. To achieve this, execute the following command:\nforge service s3\nThis command generates a new service file named s3.py within the infra/services directory, as illustrated below:\ninfra\n\u251c\u2500\u2500 services\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api_gateway.py\n    \u251c\u2500\u2500 aws_lambda.py\n    \u251c\u2500\u2500 dynamo_db.py\n    \u251c\u2500\u2500 layers.py\n    \u2514\u2500\u2500 s3.py\n\nBelow showcases the updated structure of our Service class, now incorporating the S3 service, indicating the successful integration:\ninfra/services/__init__.pyfrom infra.services.s3 import S3\nfrom infra.services.dynamo_db import DynamoDB\nfrom infra.services.api_gateway import APIGateway\nfrom infra.services.aws_lambda import AWSLambda\nfrom infra.services.layers import Layers\n\n\nclass Services:\n    def __init__(self, scope, context) -> None:\n        self.api_gateway = APIGateway(scope, context)\n        self.aws_lambda = AWSLambda(scope, context)\n        self.layers = Layers(scope)\n        self.dynamo_db = DynamoDB(scope, context)\n        self.s3 = S3(scope, context)\n\nHere is the newly established S3 class:\ninfra/services/s3from aws_cdk import aws_s3 as s3\nfrom aws_cdk import aws_s3_notifications\n\n\nclass S3:\n    def __init__(self, scope, context) -> None:\n\n        # self.s3 = s3.Bucket.from_bucket_arn(\n        #     scope,\n        #     \"S3\",\n        #     bucket_arn=context.resources[\"arns\"][\"s3_arn\"],\n        # )\n        ...\n\n    def create_trigger(self, bucket, function, stages=None):\n        if stages and self.context.stage not in stages:\n            return\n\n        notifications = aws_s3_notifications.LambdaDestination(function)\n        bucket.add_event_notification(s3.EventType.OBJECT_CREATED, notifications)\n\nAs seen, Forge has created the class with a helper method to streamline the creation of a trigger between a bucket and a lambda function.\nLet's update the class variables to directly reference our recently created bucket.\ninfra/services/s3.py 5\n 6\n 7\n 8\n 9\n10\n11\n12class S3:\n    def __init__(self, scope, context: dict) -> None:\n\n        self.images_bucket = s3.Bucket.from_bucket_arn(\n            scope,\n            \"ImagesBucket\",\n            bucket_arn=context.resources[\"arns\"][\"images_bucket\"],\n        )\n\nExcellent! This approach configures our framework to utilize each ARN on its designated stage effectively.\nIncorporating Secrets Manager into the Services Class\nSince we are dealing with emails, we must use usernames and passowrd. Hardcoding email credentials directly into the code exposes them to potential breaches. To mitigate this risk, we'll implement a more secure approach using AWS Secrets Manager, a service designed to safeguard sensitive information such as secret keys.\nTo create a new secrets manager service, simply type:\nforge service secrets_manager\n\nSimilar to the S3 class, Forge will generate the new service file within the infra/services directory and seamlessly integrate it into the Services class.\ninfra\n\u251c\u2500\u2500 services\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api_gateway.py\n    \u251c\u2500\u2500 aws_lambda.py\n    \u251c\u2500\u2500 dynamo_db.py\n    \u251c\u2500\u2500 layers.py\n    \u251c\u2500\u2500 s3.py\n    \u2514\u2500\u2500 secrets_manager.py\n\nHere's the newly established class:\ninfra/services/secrets_manager.pyfrom aws_cdk import aws_secretsmanager as secrets_manager\n\n\nclass SecretsManager:\n    def __init__(self, scope, resources) -> None:\n\n        # self.secrets_manager = secrets_manager.Secret.from_secret_complete_arn(\n        #     scope,\n        #     id=\"SecretsManager\",\n        #     secret_complete_arn=resources[\"arns\"][\"secrets_manager_arn\"],\n        # )\n        pass\n\nNow, head over to the AWS Secrets Manager panel in the AWS console and create a new secret. Within this secret, store both the email address and an app password.\n\nWarning\nNote that you shouldn't save your regular GMAIL password; instead, use an app password. Refer to Sign in with app passwords to generate your app password.\n\nNow that we have the secret ARN in hand, let's proceed to update the Secrets Manager class accordingly.\ninfra/services/secrets_manager.py 4\n 5\n 6\n 7\n 8\n 9\n10\n11class SecretsManager:\n    def __init__(self, scope, resources) -> None:\n\n        self.gmail_secret = secrets_manager.Secret.from_secret_complete_arn(\n            scope,\n            id=\"GmailSecret\",\n            secret_complete_arn=\"$GMAIL-SECRET-ARN\",\n        )\n\nUsing a Non-Public Library as Lambda Layer\nTo convert the image into a qr code, we are going to use an external library called qrcode. Unlike more popular layers, we're dealing with a library for which AWS doesn't provide a public layer.\nTo seamlessly incorporate this library, refer to the article Deploying External Layers to AWS for guidance on deploying the qrcode library. Once you obtain the ARN of your deployed Lambda layer, simply add it to the Layers class.\ninfra/services/layers.pyfrom aws_cdk import aws_lambda as _lambda\nfrom lambda_forge import Path\n\n\nclass Layers:\n    def __init__(self, scope) -> None:\n\n        self.qrcode_layer = _lambda.LayerVersion.from_layer_version_arn(\n            scope,\n            id=\"QrCodeLayer\",\n            layer_version_arn=\"$QR-CODE-LAYER-ARN\",\n        )\n\nIt's essential to include both libraries in our requirements.txt file to ensure they are installed when deploying our application.\nrequirements.txt15qrcode==7.4.2\n\nImplementing the Function to Convert Image to QR Code\nWith our layers now set up, it's time to create our new function.\nforge function qrcode --method \"POST\" --description \"Converts an image into a qr code\" --belongs-to \"images\" --no-tests --public --endpoint \"images/qrcode\"\n\nWe now have the following directory:\nfunctions\n\u2514\u2500\u2500 images\n    \u251c\u2500\u2500 qrcode\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nLet's dive into implementing this function, which will handle user input consisting of a url to convert the image parameter and an email parameter for sending notification.\nfunctions/images/img_to_qrcode/main.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59import hashlib\nimport json\nimport os\nfrom dataclasses import dataclass\nfrom io import BytesIO\n\nimport boto3\nimport qrcode\n\n\n@dataclass\nclass Input:\n    url: str\n    email: str\n\n\n@dataclass\nclass Output:\n    pass\n\n\ndef lambda_handler(event, context):\n\n    # Parse the input event to get the URL of the image and the S3 bucket name\n    body = json.loads(event[\"body\"])\n    url = body.get(\"url\")\n\n    # Retrieve the S3 bucket name from environment variables\n    bucket_name = os.environ.get(\"BUCKET_NAME\")\n\n    # Generate QR code from the image\n    qr = qrcode.QRCode()\n    qr.add_data(url)\n    qr.make()\n\n    # Create an image from the QR code\n    qr_image = qr.make_image()\n\n    # Convert the QR code image to bytes\n    qr_byte_arr = BytesIO()\n    qr_image.save(qr_byte_arr)\n    qr_byte_arr = qr_byte_arr.getvalue()\n\n    # Create the file name with a hash based on the input URL\n    file_name = f\"{hashlib.md5(url.encode()).hexdigest()}.jpg\"\n\n    # Initialize the S3 client\n    s3_client = boto3.client(\"s3\")\n\n    # Upload the QR code image to S3\n    s3_client.put_object(\n        Bucket=bucket_name,\n        Key=file_name,\n        Body=qr_byte_arr,\n        ContentType=\"image/png\",\n        Metadata={\"url\": url, \"email\": body.get(\"email\")},\n    )\n\n    return {\"statusCode\": 200}\n\nEssentially, our function retrieves the URL from the parameters provided by the user. It then utilizes the qrcode library to convert the URL into a QR code before storing it in the S3 bucket. Additionally, the function saves the original url along with the associated email as metadata for future reference.\nNow, it's configuration.\nfunctions/images/qrcode/config.pyfrom infra.services import Services\n\n\nclass QrcodeConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Qrcode\",\n            path=\"./functions/images\",\n            description=\"Converts an image into a qr code\",\n            directory=\"qrcode\",\n            layers=[services.layers.qrcode_layer],\n            environment={\n                \"BUCKET_NAME\": services.s3.images_bucket.bucket_name,\n            },\n        )\n\n        services.api_gateway.create_endpoint(\"POST\", \"/images/qrcode\", function, public=True)\n\n        services.s3.images_bucket.grant_write(function)\n\nImplementing the Mailer Function\nIt's worth noting that in our previous implementation, we deliberately omitted email notifications. This exemplifies one of the advantages of serverless architecture: the ability to completely decouple functions from each other and initiate notifications through events.\nThis is precisely the approach we're taking with the mailer function. Whenever a file is uploaded to the S3 bucket, an event will be triggered to run this Lambda function. With the assistance of metadata, the mailer Lambda function will be equipped with the necessary information to determine the appropriate email recipients for notifications.\nforge function mailer --description \"Sends an email based on metadata when image enters the bucket\" --belongs-to \"images\" --no-api --no-tests\n\nHere's how our updated directory looks now.\nfunctions\n\u251c\u2500\u2500 images\n    \u251c\u2500\u2500 mailer\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u251c\u2500\u2500 qrcode\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nLet's whip up an eye-catching HTML layout to give our email a touch of elegance.\nfunctions/images/mailer/template.html<html>\n  <head>\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        margin: 0;\n        padding: 0;\n        background-color: #f4f4f4;\n      }\n      .container {\n        background-color: #ffffff;\n        margin: 10px auto;\n        padding: 20px;\n        max-width: 600px;\n        border-radius: 8px;\n        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\n      }\n      p {\n        font-size: 16px;\n        line-height: 1.5;\n        color: #555555;\n      }\n      .logo {\n        display: block;\n        margin: 0 auto 20px auto;\n        width: 100px;\n        height: auto;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"container\">\n      <img\n        src=\"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\"\n        alt=\"Lambda Forge Logo\"\n        class=\"logo\"\n      />\n      <h1>Your Image Is Ready!</h1>\n      <p>Hello,</p>\n      <p>\n        We're excited to let you know that your image has been processed and is\n        now attached to this email.\n      </p>\n\n      <p>Please check the attachment to view it.</p>\n\n      <p>\n        Made with \u2764\ufe0f by\n        <b\n          ><a\n            href=\"https://docs.lambda-forge.com\"\n            style=\"color: inherit; text-decoration: none;\"\n            >Lambda Forge</a\n          ></b\n        >\n      </p>\n    </div>\n  </body>\n</html>\n\nTime to implement the mailer functionality!\nfunctions/images/mailer/main.pyimport os\nimport smtplib\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nimport boto3\n\n\ndef lambda_handler(event, context):\n    # Initialize the S3 client\n    s3_client = boto3.client(\"s3\")\n\n    # Fetch the SMTP details from the environment variables\n    SMTP_HOST = os.environ[\"SMTP_HOST\"]\n    SMTP_PORT = os.environ[\"SMTP_PORT\"]\n    SMTP_USER = os.environ[\"SMTP_USER\"]\n    SMTP_PASS = os.environ[\"SMTP_PASS\"]\n\n    # Extract the bucket name and the object key from the event\n    record = event[\"Records\"][0]\n    bucket_name = record[\"s3\"][\"bucket\"][\"name\"]\n    object_key = record[\"s3\"][\"object\"][\"key\"]\n\n    # Fetch the image from S3\n    response = s3_client.get_object(Bucket=bucket_name, Key=object_key)\n\n    # Extract the receiver email from the metadata\n    receiver = response[\"Metadata\"][\"email\"]\n\n    # Create the multipart email\n    msg = MIMEMultipart()\n    sender_name = \"Lambda Forge\"\n\n    # Set the 'From' field, including both the name and the email:\n    msg[\"From\"] = f\"{sender_name} <{SMTP_USER}>\"\n    msg[\"To\"] = receiver\n    msg[\"Subject\"] = \"Image Processed Successfully!\"\n\n    # Join the current directory with the filename to get the full path of the HTML file\n    current_directory = os.path.dirname(os.path.abspath(__file__))\n    html_path = os.path.join(current_directory, \"template.html\")\n\n    # Read the HTML content\n    html = open(html_path).read()\n    msg.attach(MIMEText(html, \"html\"))\n\n    # Attach the image\n    image_data = response[\"Body\"].read()\n    file_name = object_key.split(\"/\")[-1]\n    part = MIMEApplication(image_data, Name=file_name)\n    part[\"Content-Disposition\"] = f'attachment; filename=\"{file_name}\"'\n    msg.attach(part)\n\n    # Send the email via Gmail's SMTP server, or use another server if not using Gmail\n    with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT) as server:\n        server.login(SMTP_USER, SMTP_PASS)\n        server.sendmail(SMTP_USER, receiver, msg.as_string())\n\nThis function fetches essential email-sending details from environment variables such as SMTP_HOST, SMTP_PORT, SMTP_USER, and SMTP_PASS. It then retrieves the recipient's email address from the bucket's metadata and sends an email with the QR code attached.\nThe elegance of this approach lies in its flexibility. We can incorporate multiple image processors, including tasks like image resizing, applying color filters, facial recognition, and more. None of these processors need to handle email sending directly. By simply saving the processed image inside the bucket, the corresponding functionality is seamlessly applied.\nNow, let's configure our Mailer function.\nfunctions/images/mailer/config.pyfrom infra.services import Services\n\n\nclass MailerConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Mailer\",\n            path=\"./functions/images\",\n            description=\"Sends an email when an image enters the bucket\",\n            directory=\"mailer\",\n            environment={\n                \"SMTP_HOST\": \"smtp.gmail.com\",\n                \"SMTP_PORT\": \"465\",\n                \"SMTP_USER\": services.secrets_manager.gmail_secret.secret_value_from_json(\"email\").unsafe_unwrap(),\n                \"SMTP_PASS\": services.secrets_manager.gmail_secret.secret_value_from_json(\"password\").unsafe_unwrap(),\n            },\n        )\n\n        services.s3.images_bucket.grant_read(function)\n        services.s3.create_trigger(services.s3.images_bucket, function)\n\nWith our existing setup, we configure the environment variables and grant read permissions to the function for accessing the bucket. Additionally, we utilize Forge's helper method to establish a trigger that activates when an object is created in the bucket, invoking the function.\nMitigating Security Risks in Mailer Configuration\nAlthough the /mailer/config.py file may seem functional, its implementation poses a significant security risk. Hardcoding credentials directly into environment variables exposes them to potential breaches, as the secret will be visible on the Lambda Function panel.\n\nTo mitigate this risk, let's modify our main.py file slightly. Instead of retrieving the Gmail credentials from environment variables, we'll directly retrieve them from AWS Secrets Manager.\nfunctions/images/mailer/main.py11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31def lambda_handler(event, context):\n    # Initialize the S3 client\n    s3_client = boto3.client(\"s3\")\n\n    # Fetch the SMTP details from the environment variables\n    SMTP_HOST = os.environ[\"SMTP_HOST\"]\n    SMTP_PORT = os.environ[\"SMTP_PORT\"]\n\n    import json\n\n    # Initialize the Secrets Manager client\n    sm_client = boto3.client('secretsmanager')\n    secret_name = '$SECRET-NAME'\n\n    # Retrieve the secret value from Secrets Manager\n    response = sm_client.get_secret_value(SecretId=secret_name)\n    secret = json.loads(response['SecretString'])\n\n    # Extract SMTP credentials from the secret data\n    SMTP_USER = secret[\"email\"]\n    SMTP_PASS = secret[\"password\"]\n\nThat's quite a bit of boilerplate code for such a straightforward task! \ud83d\ude30 Considering the critical importance of security, we'll probably employ this code snippet in numerous functions.\nCreating a Custom Layer to Avoid Code Duplication\nTo avoid duplicating the previous code throughout our project, let's establish a new sm_utils custom layer. This approach will streamline the process, allowing all lambda functions that need to retrieve a secret from Secrets Manager to do so with just a single line of code.\nCheck out AWS Lambda Development with Custom Layers to delve deeper into custom layers in Lambda development.\nTo create the new custom layer, simply type:\nforge layer --custom sm_utils\n\nThis command creates the following directory:\nlayers\n\u251c\u2500\u2500 __init__.py\n\u2514\u2500\u2500 sm_utils\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 sm_utils.py\n\nAdditionally, a new layer has been incorporated into the Layers class.\ninfra/services/layers 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17        self.qrcode_layer = _lambda.LayerVersion.from_layer_version_arn(\n            scope,\n            id=\"QrCodeLayer\",\n            layer_version_arn=\"arn:aws:lambda:us-east-2:211125768252:layer:QRCode:1\",\n        )\n\n        self.sm_utils_layer = _lambda.LayerVersion(\n            scope,\n            id='SmUtilsLayer',\n            code=_lambda.Code.from_asset(Path.layer('layers/sm_utils')),\n            compatible_runtimes=[_lambda.Runtime.PYTHON_3_9],\n            description='',\n         )\n\nNow, it's time to level up the sm_utils layer by introducing a get_secret function. This handy feature will be shared across all our Lambda functions, simplifying our codebase.\nlayers/sm_utils/sm_utils.pyimport json\n\nimport boto3\n\n\ndef get_secret(secret_name: str):\n\n    # Initialize the Secrets Manager client\n    sm_client = boto3.client(\"secretsmanager\")\n\n    # Retrieve the secret value from Secrets Manager\n    response = sm_client.get_secret_value(SecretId=secret_name)\n\n    # Handle scenarios where the secret is stored as plain text instead of JSON.\n    try:\n        secret = json.loads(response[\"SecretString\"])\n    except json.JSONDecodeError:\n        secret = response[\"SecretString\"]\n\n    return secret\n\nRefactoring The Mailer Function to Use Custom Layers\nBelow is the updated main.py file, now leveraging the new sm_utils layer.\nfunctions/images/mailer/main.pyimport os\nimport smtplib\nfrom email.mime.application import MIMEApplication\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\n\nimport boto3\nimport sm_utils\n\n\ndef lambda_handler(event, context):\n    # Initialize the S3 client\n    s3_client = boto3.client(\"s3\")\n\n    # Fetch the SMTP details from the environment variables\n    SMTP_HOST = os.environ[\"SMTP_HOST\"]\n    SMTP_PORT = os.environ[\"SMTP_PORT\"]\n\n    # Get the secret name from env variable\n    SECRET_NAME = os.environ[\"SECRET_NAME\"]\n\n    # Get the secret from sm_utils layer\n    secret = sm_utils.get_secret(SECRET_NAME)\n\n    SMTP_USER = secret[\"email\"]\n    SMTP_PASS = secret[\"password\"]\n\n    # Extract the bucket name and the object key from the event\n    record = event[\"Records\"][0]\n    bucket_name = record[\"s3\"][\"bucket\"][\"name\"]\n    object_key = record[\"s3\"][\"object\"][\"key\"]\n\n    # Fetch the image from S3\n    response = s3_client.get_object(Bucket=bucket_name, Key=object_key)\n\n    # Extract the receiver email from the metadata\n    receiver = response[\"Metadata\"][\"email\"]\n\n    # Create the multipart email\n    msg = MIMEMultipart()\n    sender_name = \"Lambda Forge\"\n\n    # Set the 'From' field, including both the name and the email:\n    msg[\"From\"] = f\"{sender_name} <{SMTP_USER}>\"\n    msg[\"To\"] = receiver\n    msg[\"Subject\"] = \"Image Processed Successfully!\"\n\n    # Join the current directory with the filename to get the full path of the HTML file\n    current_directory = os.path.dirname(os.path.abspath(__file__))\n    html_path = os.path.join(current_directory, \"template.html\")\n\n    # Read the HTML content\n    html = open(html_path).read()\n    msg.attach(MIMEText(html, \"html\"))\n\n    # Attach the image\n    image_data = response[\"Body\"].read()\n    file_name = object_key.split(\"/\")[-1]\n    part = MIMEApplication(image_data, Name=file_name)\n    part[\"Content-Disposition\"] = f'attachment; filename=\"{file_name}\"'\n    msg.attach(part)\n\n    # Send the email via Gmail's SMTP server, or use another server if not using Gmail\n    with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT) as server:\n        server.login(SMTP_USER, SMTP_PASS)\n        server.sendmail(SMTP_USER, receiver, msg.as_string())\n\nNow, let's adjust the configuration to accommodate the changes necessary for the function.\nfunctions/images/mailer/config.pyfrom infra.services import Services\n\n\nclass MailerConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Mailer\",\n            path=\"./functions/images\",\n            description=\"Sends an email when an image enters the bucket\",\n            directory=\"mailer\",\n            layers=[services.layers.sm_utils_layer],\n            environment={\n                \"SMTP_HOST\": \"smtp.gmail.com\",\n                \"SMTP_PORT\": \"465\",\n                \"SECRET_NAME\": services.secrets_manager.gmail_secret.secret_name,\n            },\n        )\n\n        services.s3.images_bucket.grant_read(function)\n        services.s3.create_trigger(services.s3.images_bucket, function)\n\n        services.secrets_manager.gmail_secret.grant_read(function)\n\nDeploying The Functions\nNext, we'll commit our code and push it to GitHub, following these steps:\n# Send your changes to stage\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"Image to QR code converter with result being sent by email\"\n\n# Push changes to the 'dev' branch\ngit push origin dev\n\n# Merge 'dev' into 'staging' and push\ngit checkout staging\ngit merge dev\ngit push origin staging\n\n# Finally, merge 'staging' into 'main' and push\ngit checkout main\ngit merge staging\ngit push origin main\n\nThis process guarantees that our code transitions systematically through the development, staging, and production environments. It activates our three specialized deployment pipelines, as illustrated by the pipelines running in the accompanying image.\n\nFollowing the successful execution of these pipelines, the Image to QR code feature becomes accessible across the development, staging, and production stages, ensuring a seamless deployment.\nTesting the Image to QR Code Conversion\nWe'll walk through testing our Image to QR Code Converter, focusing on the production environment for this demonstration. The procedure remains consistent across development and staging environments, with the only difference being the specific endpoints used.\nTo convert an image URL into a QR code, we execute the following POST request:\ncurl --request POST \\\n  --url https://api.lambda-forge.com/images/qrcode \\\n  --header 'Content-Type: application/json' \\\n  --data '{\n    \"url\": \"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\",\n    \"email\": \"$EMAIL\"\n}'\n\nShortly after the request is made, an email is dispatched to the provided address.\n\nThe email contains a QR code attachment, as seen in the illustration below:\n\n\n\nUpon scanning the QR code, the original image is displayed:\n\n\ud83c\udf89 Success! The Image to QR Code Converter function is now fully deployed and operational in all environments. \ud83d\ude80\u2728\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}