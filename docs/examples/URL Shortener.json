{
  "url": "https://docs.lambda-forge.com/examples/url-shortener/",
  "title": "URL Shortener - Lambda Forge",
  "content": "\n\n\n\n\n\n\n\n\n\nURL Shortener - Lambda Forge\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n          Skip to content\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Lambda Forge\n          \n\n\n\n            \n              URL Shortener\n            \n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n            Initializing search\n          \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n  \n    \n  \n  Home\n\n      \n\n\n\n          \n  \n  Docs\n\n        \n\n\n\n          \n  \n  Example Projects\n\n        \n\n\n\n          \n  \n  Articles\n\n        \n\n\n\n        \n  \n    \n  \n  License\n\n      \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    Lambda Forge\n  \n\n\n\n\n    Home\n  \n\n\n\n\n\n\n    Docs\n  \n\n\n\n\n\n            Docs\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n    Getting Started\n  \n\n\n\n\n\n    Creating a Hello World\n  \n\n\n\n\n\n    Securing Endpoints\n  \n\n\n\n\n\n    Lambda Layers\n  \n\n\n\n\n\n    Multi-Stage Environments\n  \n\n\n\n\n\n    Custom CodePipeline Steps\n  \n\n\n\n\n\n    Docs Generation\n  \n\n\n\n\n\n    Pre-Commit Hooks\n  \n\n\n\n\n\n\n\n\n\n    Example Projects\n  \n\n\n\n\n\n            Example Projects\n          \n\n\n\n\n    Introduction\n  \n\n\n\n\n\n\n    Begginer\n  \n\n\n\n\n\n            Begginer\n          \n\n\n\n\n    Guess The Number\n  \n\n\n\n\n\n\n    URL Shortener\n  \n\n\n\n\n    URL Shortener\n  \n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Configuring DynamoDB Tables for Each Deployment Stage\n    \n\n\n\n\n\n\n      Incorporating DynamoDB Into the Service Class\n    \n\n\n\n\n\n\n\n\n      Implementing the Shortener Function\n    \n\n\n\n\n\n      Implementing the Redirect Function\n    \n\n\n\n\n\n      Deploying the Functions\n    \n\n\n\n\n\n      Testing The Deployment\n    \n\n\n\n\n\n\n\n\n    Image to QR Code Converter\n  \n\n\n\n\n\n\n\n\n\n    Intermediate\n  \n\n\n\n\n\n            Intermediate\n          \n\n\n\n\n    JWT Authentication\n  \n\n\n\n\n\n    OAuth2 Authentication\n  \n\n\n\n\n\n    Real-Time Chat\n  \n\n\n\n\n\n    Web Scraper\n  \n\n\n\n\n\n\n\n\n\n    Advanced\n  \n\n\n\n\n\n            Advanced\n          \n\n\n\n\n    Data Processing Pipeline\n  \n\n\n\n\n\n    Stock Price Tracker\n  \n\n\n\n\n\n\n\n\n\n\n\n\n    Articles\n  \n\n\n\n\n\n            Articles\n          \n\n\n\n\n    Custom Domain Name\n  \n\n\n\n\n\n    Tests with Lambda Forge\n  \n\n\n\n\n\n    Deploying External Library as Layers\n  \n\n\n\n\n\n    Creating S3 Buckets\n  \n\n\n\n\n\n    Locating the Base URL\n  \n\n\n\n\n\n    JSON Web Tokens\n  \n\n\n\n\n\n\n\n\n    License\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n      Table of contents\n    \n\n\n\n\n      Configuring DynamoDB Tables for Each Deployment Stage\n    \n\n\n\n\n\n\n      Incorporating DynamoDB Into the Service Class\n    \n\n\n\n\n\n\n\n\n      Implementing the Shortener Function\n    \n\n\n\n\n\n      Implementing the Redirect Function\n    \n\n\n\n\n\n      Deploying the Functions\n    \n\n\n\n\n\n      Testing The Deployment\n    \n\n\n\n\n\n\n\n\n\nCreating a URL Shortener Service Using DynamoDB\nIn this section, we will explore the development of a URL shortener. This utility enables users to input a lengthy URL, which the system then compresses into a more concise version.\nConfiguring DynamoDB Tables for Each Deployment Stage\nTo ensure our application can operate smoothly across different environments, we'll create three separate DynamoDB tables on AWS DynamoDB console, each tailored for a distinct deployment stage: Dev-URLs, Staging-URLs and Prod-URLs.\n\nNote\nThroughout this tutorial, we'll utilize PK as the Partition Key for all of our DynamoDB tables.\n\nHaving acquired the ARNs for each stage-specific table, our next step involves integrating these ARNs into the cdk.json file. This crucial configuration enables our Cloud Development Kit (CDK) setup to correctly reference the DynamoDB tables according to the deployment stage.\nHere's how to update your cdk.json file to include the DynamoDB table ARNs for development, staging, and production environments:\ncdk.json51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65    \"dev\": {\n      \"arns\": {\n        \"urls_table\": \"$DEV-URLS-TABLE-ARN\"\n      }\n    },\n    \"staging\": {\n      \"arns\": {\n        \"urls_table\": \"$STAGING-URLS-TABLE-ARN\"\n      }\n    },\n    \"prod\": {\n      \"arns\": {\n        \"urls_table\": \"$PROD-URLS-TABLE-ARN\"\n      }\n    }\n\nIncorporating DynamoDB Into the Service Class\nThe subsequent phase in enhancing our application involves integrating the DynamoDB service within our service layer, enabling direct communication with DynamoDB tables. To accomplish this, utilize the following command:\nforge service dynamo_db\nThis command creates a new service file named dynamo_db.py within the infra/services directory.\ninfra\n\u251c\u2500\u2500 services\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 api_gateway.py\n    \u251c\u2500\u2500 aws_lambda.py\n    \u251c\u2500\u2500 dynamo_db.py\n    \u2514\u2500\u2500 layers.py\n\nBelow is the updated structure of our Service class, now including the DynamoDB service, demonstrating the integration's completion:\ninfra/services/__init__.pyfrom infra.services.dynamo_db import DynamoDB\nfrom infra.services.api_gateway import APIGateway\nfrom infra.services.aws_lambda import AWSLambda\nfrom infra.services.layers import Layers\n\n\nclass Services:\n    def __init__(self, scope, context) -> None:\n        self.api_gateway = APIGateway(scope, context)\n        self.aws_lambda = AWSLambda(scope, context)\n        self.layers = Layers(scope)\n        self.dynamo_db = DynamoDB(scope, context)\n\nHere is the newly established DynamoDB class:\ninfra/services/dynamo_db.pyfrom aws_cdk import aws_dynamodb as dynamo_db\nfrom aws_cdk import aws_iam as iam\n\n\nclass DynamoDB:\n    def __init__(self, scope, context: dict) -> None:\n\n        # self.dynamo = dynamo_db.Table.from_table_arn(\n        #     scope,\n        #     \"Dynamo\",\n        #     context.resources[\"arns\"][\"dynamo_arn\"],\n        # )\n        ...\n\n    @staticmethod\n    def add_query_permission(table, function):\n        function.add_to_role_policy(\n            iam.PolicyStatement(\n                actions=[\"dynamodb:Query\"],\n                resources=[f\"{table.table_arn}/index/*\"],\n            )\n        )\n\nForge has already laid the groundwork by providing a commented code that outlines the structure for creating a DynamoDB table and retrieving its ARN from the cdk.json file. Additionally, it's worth noting that the DynamoDB class includes a specialized helper method aimed at streamlining the task of assigning query permissions.\nLet's refine the class variables to directly reference our URLs table.\ninfra/services/dynamo_db.py 5\n 6\n 7\n 8\n 9\n10\n11\n12class DynamoDB:\n    def __init__(self, scope, context: dict) -> None:\n\n        self.urls_table = dynamo_db.Table.from_table_arn(\n            scope,\n            \"URLsTable\",\n            context.resources[\"arns\"][\"urls_table\"],\n        )\n\nThe context.resources object on line 11 contains only the resources that are pertinent to the current stage. By tapping into this, we can dynamically tweak our AWS resources according to the specific stage we're operating in.\nImplementing the Shortener Function\nTo initiate, let's develop the shortener function, which serves as the primary interface for user interaction. This function is tasked with accepting a lengthy URL from the user and providing them with its shortened counterpart in response:\nforge function shortener --method \"POST\" --description \"Creates a new short URL entry in DynamoDB mapped to the original one\" --belongs-to urls --public --no-tests\n\nExecuting the command will result in the establishment of the following directory structure:\nfunctions\n\u2514\u2500\u2500 urls\n    \u251c\u2500\u2500 shortener\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u251c\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nNow, let's implement it's functionality:\nfunctions/urls/shortener/main.py 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43from dataclasses import dataclass\nimport hashlib\nimport json\nimport os\nimport boto3\n\n@dataclass\nclass Input:\n    url: str\n\n\n@dataclass\nclass Output:\n    short_url: str\n\n\ndef lambda_handler(event, context):\n    # Retrieve DynamoDB table name and the Base URL from environment variables.\n    URLS_TABLE_NAME = os.environ.get(\"URLS_TABLE_NAME\")\n    BASE_URL = os.environ.get(\"BASE_URL\")\n\n    # Initialize DynamoDB resource.\n    dynamodb = boto3.resource(\"dynamodb\")\n\n    # Reference the specified DynamoDB table.\n    urls_table = dynamodb.Table(URLS_TABLE_NAME)\n\n    # Parse the URL from the incoming event's body.\n    body = json.loads(event[\"body\"])\n    original_url = body[\"url\"]\n\n    # Generate a URL hash.\n    hash_object = hashlib.sha256(original_url.encode())\n    url_id = hash_object.hexdigest()[:6]\n\n    # Store the mapping in DynamoDB.\n    urls_table.put_item(Item={\"PK\": url_id, \"original_url\": original_url})\n\n    # Construct the shortened URL.\n    short_url = f\"{BASE_URL}/{url_id}\"\n\n    # Return success response.\n    return {\"statusCode\": 200, \"body\": json.dumps({\"short_url\": short_url})}\n\nThis code is the core of our URL shortening service. It transforms long URLs into shorter, hash-based versions, and storing this information in DynamoDB for future retrieval.\nSince we are operating in a multi-stage environment, this function is dynamically retrieving the BASE URL from environment variables, as shown on line 20. This approach ensures stage-specific responses, enabling seamless URL customization.\nTo make this possible, we must incorporate the base URL into the cdk.json file and implement minor modifications. These adjustments will enable the base URL to be accessible within the config.py class, thereby allowing the function to access the appropriate base URL depending on the environment it's operating in.\ncdk.json51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68    \"dev\": {\n      \"base_url\": \"https://api.lambda-forge.com/dev\",\n      \"arns\": {\n        \"urls_table\": \"$DEV-URLS-TABLE-ARN\"\n      }\n    },\n    \"staging\": {\n      \"base_url\": \"https://api.lambda-forge.com/staging\",\n      \"arns\": {\n        \"urls_table\": \"$STAGING-URLS-TABLE-ARN\"\n      }\n    },\n    \"prod\": {\n      \"base_url\": \"https://api.lambda-forge.com\",\n      \"arns\": {\n        \"urls_table\": \"$PROD-URLS-TABLE-ARN\"\n      }\n    }\n\n\nNote\n\nFollow the article Finding the Api Gateway Base URL to locate your own base URL in each environment.\n\n\nInitially, the LambdaStack class sends only the self.services as argument to the ShortenerConfig class. We must update it to also send the context parameter. This change allows the config class to access base URLs and dynamically set the correct environment variables during the function definition, enhancing its adaptability.\ninfra/stacks/lambda_stack.py19\n20\n21\n22\n23\n24\n25\n26\n27class LambdaStack(Stack):\n    def __init__(self, scope: Construct, context, **kwargs) -> None:\n\n        super().__init__(scope, f\"{context.name}-Lambda-Stack\", **kwargs)\n\n        self.services = Services(self, context)\n\n        # Urls\n        ShortenerConfig(self.services, context)\n\nTo conclude, we will now proceed with configuring our Lambda function.\nfunctions/urls/config.pyfrom infra.services import Services\n\nclass ShortenerConfig:\n    def __init__(self, services: Services, context) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Shortener\",\n            path=\"./functions/urls\",\n            description=\"Creates a new short URL entry in DynamoDB mapping to the original url\",\n            directory=\"shortener\",\n            environment={\n                \"URLS_TABLE_NAME\": services.dynamo_db.urls_table.table_name,\n                \"BASE_URL\": context.resources[\"base_url\"],\n            },\n        )\n\n        services.api_gateway.create_endpoint(\"POST\", \"/urls\", function, public=True)\n\n        services.dynamo_db.urls_table.grant_write_data(function)\n\nIn this configuration, we specify resources according to the deployment stages of the Lambda function, setting up the DynamoDB table and API Gateway base URL accordingly. It also includes permission settings, enabling the Lambda function to write to our DynamoDB table.\nImplementing the Redirect Function\nHaving established the necessary components for URL shortening, we now proceed to create a new function tasked with redirecting users from the shortened URL to its original counterpart.\nBegin by creating a new function:\nforge function redirect --method \"GET\" --description \"Redirects from the short url to the original url\" --belongs-to urls --public --no-tests\n\nThe revised directory structure will appear as follows:\nfunctions\n\u2514\u2500\u2500 urls\n    \u251c\u2500\u2500 redirect\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u251c\u2500\u2500 shortener\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 config.py\n    \u2502   \u2514\u2500\u2500 main.py\n    \u2514\u2500\u2500 utils\n        \u2514\u2500\u2500 __init__.py\n\nNow, let's implement the redirect functionality.\nfunctions/urls/redirect/main.pyfrom dataclasses import dataclass\nimport json\nimport boto3\nimport os\n\n\n@dataclass\nclass Path:\n    url_id: str\n\n\n@dataclass\nclass Input:\n    pass\n\n\n@dataclass\nclass Output:\n    pass\n\n\ndef lambda_handler(event, context):\n\n    # Retrieve DynamoDB table name from environment variables.\n    URLS_TABLE_NAME = os.environ.get(\"URLS_TABLE_NAME\")\n\n    # Initialize DynamoDB resource and table reference.\n    dynamodb = boto3.resource(\"dynamodb\")\n    urls_table = dynamodb.Table(URLS_TABLE_NAME)\n\n    # Extract shortened URL identifier from path parameters.\n    short_url = event[\"pathParameters\"][\"url_id\"]\n\n    # Retrieve the original URL using the shortened identifier.\n    response = urls_table.get_item(Key={\"PK\": short_url})\n    original_url = response.get(\"Item\", {}).get(\"original_url\")\n\n    # Return 404 if no URL is found for the identifier.\n    if original_url is None:\n        return {\"statusCode\": 404, \"body\": json.dumps({\"message\": \"URL not found\"})}\n\n    # Ensure URL starts with \"http://\" or \"https://\".\n    if not original_url.startswith(\"http\"):\n        original_url = f\"http://{original_url}\"\n\n    # Redirect to the original URL with a 301 Moved Permanently response.\n    return {\"statusCode\": 301, \"headers\": {\"Location\": original_url}}\n\nIn this Lambda function, we're essentially setting up a redirect service. When a request comes in with a short URL identifier, the function looks up this identifier in the DynamoDB table to find the corresponding original URL. If found, it redirects the user to the original URL.\nNext, let's move on to its configuration.\nfunctions/urls/redirect/config.pyfrom infra.services import Services\n\n\nclass RedirectConfig:\n    def __init__(self, services: Services) -> None:\n\n        function = services.aws_lambda.create_function(\n            name=\"Redirect\",\n            path=\"./functions/urls\",\n            description=\"Redirects from the short url to the original url\",\n            directory=\"redirect\",\n            environment={\n                \"URLS_TABLE_NAME\": services.dynamo_db.urls_table.table_name,\n            }\n        )\n\n        services.api_gateway.create_endpoint(\"GET\", \"/{url_id}\", function, public=True)\n\n        services.dynamo_db.urls_table.grant_read_data(function)\n\nDeploying the Functions\nNext, we'll commit our code and push it to GitHub, following these steps:\n# Send your changes to stage\ngit add .\n\n# Commit with a descriptive message\ngit commit -m \"URL Shortener with DynamoDB integration\"\n\n# Push changes to the 'dev' branch\ngit push origin dev\n\n# Merge 'dev' into 'staging' and push\ngit checkout staging\ngit merge dev\ngit push origin staging\n\n# Finally, merge 'staging' into 'main' and push\ngit checkout main\ngit merge staging\ngit push origin main\n\nThis sequence ensures our code passes through development, staging, and finally, production environments, activating our three distinct deployment pipelines.\n\nAfter the pipelines complete, the URL Shortener feature is available across development, staging, and production stages.\nTesting The Deployment\nLet's test our URL Shortener by shortening a lengthy URL. For demonstration purposes, we'll use the production environment, but the process remains identical for development and staging, using their respective endpoints.\nExecute a POST request to shorten the URL:\ncurl --request POST \\\n  --url https://api.lambda-forge.com/urls \\\n  --header 'Content-Type: application/json' \\\n  --header 'accept: application/json' \\\n  --data '{\n    \"url\": \"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\"\n}'\n\nThis request generates a short URL:\n{\n  \"short_url\": \"https://api.lambda-forge.com/bc23d3\"\n}\n\nNavigating to this URL in your browser will redirect you to the original content, showcasing our URL Shortener in action.\n\n\ud83c\udf89 Success! Our URL shortener function is now deployed and operational across all environments.\n\n\n\n\n\n\n\n  Back to top\n\n\n\n\n\n\n\n      \u00a9 2024 Guilherme Alves Pimenta\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
}