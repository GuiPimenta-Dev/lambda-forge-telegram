[
  {
    "url": "https://docs.lambda-forge.com/home/introduction/",
    "title": "Introduction - Lambda Forge",
    "content": "Introduction - Lambda Forge Skip to content Lambda Forge Introduction Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Introduction Table of contents Welcome to Lambda Forge Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Welcome to Lambda Forge Introduction Welcome to Lambda Forge Lambda Forge is a Python framework, built on top of AWS Cloud Development Kit, that revolutionizes the AWS Lambda deployment enabling a modular and scalable architecture with an automated CI/CD pipeline for a multi-stage environment. Additionally, it includes a Command Line Interface named Forge, designed to optimize your development workflow. Forge not only speeds up and standardizes the development process but also automatically generates comprehensive documentation for your endpoints using Swagger and Redoc. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/home/creating-a-hello-world/",
    "title": "Creating a Hello World - Lambda Forge",
    "content": "Creating a Hello World - Lambda Forge Skip to content Lambda Forge Creating a Hello World Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Creating a Hello World Table of contents Understanding the Function Structure Implementing the Hello World Function Configuring Your Lambda Function Dependencies The Services Class Utilizing the Services Class in config.py Deploying Your Lambda Function Push Your Code To Github Deploying the Stacks Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Understanding the Function Structure Implementing the Hello World Function Configuring Your Lambda Function Dependencies The Services Class Utilizing the Services Class in config.py Deploying Your Lambda Function Push Your Code To Github Deploying the Stacks Creating a Public Hello World Function With API Gateway Creating a public \"Hello World\" function is a fantastic way to get started with Lambda Forge. This function will serve as a simple demonstration of Lambda Forge's ability to quickly deploy serverless functions accessible via an HTTP endpoint. Here's how you can create your first public Hello World function. forge function hello_world --method \"GET\" --description \"A simple hello world\" --public This command prompts Lambda Forge to initiate a new Lambda function located in the hello_world directory. The --method parameter defines the HTTP method accessible for this function.. The --description option provides a concise summary of the function\u2019s intent, and the --public flag ensures the function is openly accessible, allowing it to be invoked by anyone who has the URL. Understanding the Function Structure When you create a new function with Lambda Forge, it not only simplifies the creation process but also sets up a robust and organized file structure for your function. This structure is designed to support best practices in software development, including separation of concerns, configuration management, and testing. Let's break down the structure of the automatically generated hello_world function: functions/ \u2514\u2500\u2500 hello_world/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config.py \u251c\u2500\u2500 integration.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 unit.py functions/ This directory is the root folder for all your Lambda functions. Each function has its own subdirectory within this folder. hello_world/ The hello_world subdirectory contains all the necessary files for your function to run, be configured, and tested. __init__.py This file marks the directory as a Python package, allowing its modules to be imported elsewhere. config.py Holds the configuration settings for the function. These might include environment variables, resource identifiers, and other parameters critical for the function's operation. integration.py Contains integration tests that simulate the interaction of your function with external services or resources. main.py This is where the core logic of your Lambda function resides. The handler function, which AWS Lambda invokes when the function is executed, is defined here. unit.py Contains unit tests for your function. Unit tests focus on testing individual parts of the function's code in isolation, ensuring that each component behaves as expected. Implementing the Hello World Function The Lambda function's implementation should be in the main.py file. Below is an example showcasing our simple HelloWorld function: functions/hello_world/main.pyimport json from dataclasses import dataclass @dataclass class Input: pass @dataclass class Output: message: str def lambda_handler(event, context): return { \"statusCode\": 200, \"body\": json.dumps({\"message\": \"Hello World!\"}) } The Input and Output data classes are the entrypoint for the documentation creation process. However, since the project was launched with the --no-docs flag, we will temporarily skip the docs generation details. Moving forward, we've successfully implemented a straightforward lambda function that outputs a basic JSON response: {\"message\": \"Hello World!\"}. Configuring Your Lambda Function Dependencies The Services Class Within the infra/services/__init__.py file, you'll find the Services class, a comprehensive resource manager designed to streamline the interaction with AWS services. This class acts as a dependency injector, enabling the easy and efficient configuration of AWS resources directly from your config.py files. infra/services/__init__.pyfrom infra.services.api_gateway import APIGateway from infra.services.aws_lambda import AWSLambda from infra.services.layers import Layers class Services: def __init__(self, scope, context) -> None: self.api_gateway = APIGateway(scope, context) self.aws_lambda = AWSLambda(scope, context) self.layers = Layers(scope) Utilizing the Services Class in config.py In our Lambda Forge projects, the config.py file plays a crucial role in defining and configuring the dependencies required by a Lambda function. By passing an instance of Services to our configuration classes, we can seamlessly create and manage resources such as Lambda functions and API Gateway endpoints. functions/hello_world/config.pyfrom infra.services import Services class HelloWorldConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"HelloWorld\", path=\"./functions/hello_world\", description=\"A simple hello world\" ) services.api_gateway.create_endpoint(\"GET\", \"/hello_world\", function, public=True) The Forge CLI has significantly simplified the setup by automatically tailoring the function to meet our specifications. Essentially, the config.py file configures a Lambda Function to be named as HelloWorld accompanied by the description A simple hello world. Additionally, it sets up the function to respond to GET requests at the /hello_world path and designates it as a public endpoint, making it accessible without authentication. Deploying Your Lambda Function To deploy your Lambda function, you should integrate the Config class within the infra/stacks/lambda_stack.py file. The Forge CLI streamlines this process by automatically incorporating it for you. infra/stacks/lambda_stack.pyfrom aws_cdk import Stack from constructs import Construct from infra.services import Services from lambda_forge import release from functions.hello_world.config import HelloWorldConfig @release class LambdaStack(Stack): def __init__(self, scope: Construct, context, **kwargs) -> None: super().__init__(scope, f\"{context.name}-Lambda-Stack\", **kwargs) self.services = Services(self, context) # HelloWorld HelloWorldConfig(self.services) Push Your Code To Github With all the required settings now in place, we're ready to upload our code to the GitHub repository. Lambda Forge is designed to support a multi-stage deployment process, automatically creating environments for Production, Staging and Development. These environments correspond to the main, staging, and dev branches, respectively. For the sake of simplicity, we'll focus on deploying only the development branch at this moment, deferring the discussion on setting up a multi-stage environment to a future session. # Initialize the Git repository git init git add . # Commit the changes git commit -m \"Initial commit\" # Set the remote repository git remote add origin git@github.com:$GITHUB_USER/$GITHUB_REPO.git # Create, checkout, and push the 'dev' branch git checkout -b dev git push -u origin dev Deploying the Stacks Lambda Forge ensures that every resource it creates on AWS follows a naming convention that integrates the deployment stage, the project name, and the resource name. This approach guarantees a consistent and clear identification methodology throughout the project. The project name is defined within the cdk.json file, linking each resource directly to its associated project and stage for easy management and recognition. cdk.json \"region\": \"us-east-2\", \"account\": \"\", \"name\": \"Lambda-Forge-Demo\", \"repo\": { \"owner\": \"$GITHUB-OWNER\", \"name\": \"$GITHUB-REPO\" }, Deploy the Dev Stack by running the following command in your terminal: cdk deploy Dev-Lambda-Forge-Demo-Stack Following a successful deployment, a new pipeline will be created with the name Dev-Lambda-Forge-Demo-Pipeline. Access your AWS CodePipeline console to view it. In a dedicated session, we'll delve into the specifics of the pipelines generated, including a closer examination of the development pipeline. By default, Lambda Forge does not incorporate any steps for code validation in the dev pipeline. Instead, it seamlessly integrates Github with AWS CodePipeline. This means that once code is pushed to GitHub, it triggers the pipeline, leading to automatic deployment upon the completion of the execution process. After the pipeline execution concludes, proceed to your AWS Lambda console and locate the Dev-Lambda-Forge-Demo-HelloWorld function. Select the function, then navigate to Configurations -> Triggers. Here, you will be presented with a link to your newly deployed Lambda function, ready for use. For this tutorial, the Lambda function is accessible via the following URL: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/hello_world Congratulations! \ud83c\udf89 You've successfully deployed your very first Hello World function using Lambda Forge! \ud83d\ude80 Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/license/license/",
    "title": "License - Lambda Forge",
    "content": "License - Lambda Forge Lambda Forge License Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License License MIT License Copyright (c) 2024 Guilherme Alves Pimenta Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/examples/image-to-qr-code-converter/",
    "title": "Image to QR Code Converter - Lambda Forge",
    "content": "Image to QR Code Converter - Lambda Forge Skip to content Lambda Forge Image to QR Code Converter Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Image to QR Code Converter Table of contents Incorporating S3 Into the Service Class Incorporating Secrets Manager into the Services Class Using a Non-Public Library as Lambda Layer Implementing the Function to Convert Image to QR Code Implementing the Mailer Function Mitigating Security Risks in Mailer Configuration Creating a Custom Layer to Avoid Code Duplication Refactoring The Mailer Function to Use Custom Layers Deploying The Functions Testing the Image to QR Code Conversion Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Incorporating S3 Into the Service Class Incorporating Secrets Manager into the Services Class Using a Non-Public Library as Lambda Layer Implementing the Function to Convert Image to QR Code Implementing the Mailer Function Mitigating Security Risks in Mailer Configuration Creating a Custom Layer to Avoid Code Duplication Refactoring The Mailer Function to Use Custom Layers Deploying The Functions Testing the Image to QR Code Conversion Converting Image to QR Code with AWS S3, Secrets Manager and Email Notifications In this part, we're going to cover how to make a function that turns images uploaded by users into QR codes. When a user sends a request, the image gets processed, saved on Amazon S3, and then sent to them via email so they can easily check out the results. Incorporating S3 Into the Service Class Let's start creating three distinct buckets, each dedicated to a specific stage: Dev-Lambda-Forge-Images, Staging-Lambda-Forge-Images and Prod-Lambda-Forge-Images. Note Keep in mind that your bucket name must be unique across all AWS regions. Therefore, you'll need to select distinct names for your project. Now place the arns on your cdk.json. cdk.json51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \"dev\": { \"base_url\": \"https://api.lambda-forge.com/dev\", \"arns\": { \"urls_table\": \"$DEV-URLS-TABLE-ARN\", \"images_bucket\": \"$DEV-IMAGES-BUCKET-ARN\" } }, \"staging\": { \"base_url\": \"https://api.lambda-forge.com/staging\", \"arns\": { \"urls_table\": \"$STAGING-URLS-TABLE-ARN\", \"images_bucket\": \"$STAGING-IMAGES-BUCKET-ARN\" } }, \"prod\": { \"base_url\": \"https://api.lambda-forge.com\", \"arns\": { \"urls_table\": \"$PROD-URLS-TABLE-ARN\", \"images_bucket\": \"$PROD-IMAGES-BUCKET-ARN\" } } The next step involves integrating the S3 service into our service layer, facilitating direct communication with S3 buckets. To achieve this, execute the following command: forge service s3 This command generates a new service file named s3.py within the infra/services directory, as illustrated below: infra \u251c\u2500\u2500 services \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_gateway.py \u251c\u2500\u2500 aws_lambda.py \u251c\u2500\u2500 dynamo_db.py \u251c\u2500\u2500 layers.py \u2514\u2500\u2500 s3.py Below showcases the updated structure of our Service class, now incorporating the S3 service, indicating the successful integration: infra/services/__init__.pyfrom infra.services.s3 import S3 from infra.services.dynamo_db import DynamoDB from infra.services.api_gateway import APIGateway from infra.services.aws_lambda import AWSLambda from infra.services.layers import Layers class Services: def __init__(self, scope, context) -> None: self.api_gateway = APIGateway(scope, context) self.aws_lambda = AWSLambda(scope, context) self.layers = Layers(scope) self.dynamo_db = DynamoDB(scope, context) self.s3 = S3(scope, context) Here is the newly established S3 class: infra/services/s3from aws_cdk import aws_s3 as s3 from aws_cdk import aws_s3_notifications class S3: def __init__(self, scope, context) -> None: # self.s3 = s3.Bucket.from_bucket_arn( # scope, # \"S3\", # bucket_arn=context.resources[\"arns\"][\"s3_arn\"], # ) ... def create_trigger(self, bucket, function, stages=None): if stages and self.context.stage not in stages: return notifications = aws_s3_notifications.LambdaDestination(function) bucket.add_event_notification(s3.EventType.OBJECT_CREATED, notifications) As seen, Forge has created the class with a helper method to streamline the creation of a trigger between a bucket and a lambda function. Let's update the class variables to directly reference our recently created bucket. infra/services/s3.py 5 6 7 8 9 10 11 12class S3: def __init__(self, scope, context: dict) -> None: self.images_bucket = s3.Bucket.from_bucket_arn( scope, \"ImagesBucket\", bucket_arn=context.resources[\"arns\"][\"images_bucket\"], ) Excellent! This approach configures our framework to utilize each ARN on its designated stage effectively. Incorporating Secrets Manager into the Services Class Since we are dealing with emails, we must use usernames and passowrd. Hardcoding email credentials directly into the code exposes them to potential breaches. To mitigate this risk, we'll implement a more secure approach using AWS Secrets Manager, a service designed to safeguard sensitive information such as secret keys. To create a new secrets manager service, simply type: forge service secrets_manager Similar to the S3 class, Forge will generate the new service file within the infra/services directory and seamlessly integrate it into the Services class. infra \u251c\u2500\u2500 services \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 api_gateway.py \u251c\u2500\u2500 aws_lambda.py \u251c\u2500\u2500 dynamo_db.py \u251c\u2500\u2500 layers.py \u251c\u2500\u2500 s3.py \u2514\u2500\u2500 secrets_manager.py Here's the newly established class: infra/services/secrets_manager.pyfrom aws_cdk import aws_secretsmanager as secrets_manager class SecretsManager: def __init__(self, scope, resources) -> None: # self.secrets_manager = secrets_manager.Secret.from_secret_complete_arn( # scope, # id=\"SecretsManager\", # secret_complete_arn=resources[\"arns\"][\"secrets_manager_arn\"], # ) pass Now, head over to the AWS Secrets Manager panel in the AWS console and create a new secret. Within this secret, store both the email address and an app password. Warning Note that you shouldn't save your regular GMAIL password; instead, use an app password. Refer to Sign in with app passwords to generate your app password. Now that we have the secret ARN in hand, let's proceed to update the Secrets Manager class accordingly. infra/services/secrets_manager.py 4 5 6 7 8 9 10 11class SecretsManager: def __init__(self, scope, resources) -> None: self.gmail_secret = secrets_manager.Secret.from_secret_complete_arn( scope, id=\"GmailSecret\", secret_complete_arn=\"$GMAIL-SECRET-ARN\", ) Using a Non-Public Library as Lambda Layer To convert the image into a qr code, we are going to use an external library called qrcode. Unlike more popular layers, we're dealing with a library for which AWS doesn't provide a public layer. To seamlessly incorporate this library, refer to the article Deploying External Layers to AWS for guidance on deploying the qrcode library. Once you obtain the ARN of your deployed Lambda layer, simply add it to the Layers class. infra/services/layers.pyfrom aws_cdk import aws_lambda as _lambda from lambda_forge import Path class Layers: def __init__(self, scope) -> None: self.qrcode_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"QrCodeLayer\", layer_version_arn=\"$QR-CODE-LAYER-ARN\", ) It's essential to include both libraries in our requirements.txt file to ensure they are installed when deploying our application. requirements.txt15qrcode==7.4.2 Implementing the Function to Convert Image to QR Code With our layers now set up, it's time to create our new function. forge function qrcode --method \"POST\" --description \"Converts an image into a qr code\" --belongs-to \"images\" --no-tests --public --endpoint \"images/qrcode\" We now have the following directory: functions \u2514\u2500\u2500 images \u251c\u2500\u2500 qrcode \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Let's dive into implementing this function, which will handle user input consisting of a url to convert the image parameter and an email parameter for sending notification. functions/images/img_to_qrcode/main.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59import hashlib import json import os from dataclasses import dataclass from io import BytesIO import boto3 import qrcode @dataclass class Input: url: str email: str @dataclass class Output: pass def lambda_handler(event, context): # Parse the input event to get the URL of the image and the S3 bucket name body = json.loads(event[\"body\"]) url = body.get(\"url\") # Retrieve the S3 bucket name from environment variables bucket_name = os.environ.get(\"BUCKET_NAME\") # Generate QR code from the image qr = qrcode.QRCode() qr.add_data(url) qr.make() # Create an image from the QR code qr_image = qr.make_image() # Convert the QR code image to bytes qr_byte_arr = BytesIO() qr_image.save(qr_byte_arr) qr_byte_arr = qr_byte_arr.getvalue() # Create the file name with a hash based on the input URL file_name = f\"{hashlib.md5(url.encode()).hexdigest()}.jpg\" # Initialize the S3 client s3_client = boto3.client(\"s3\") # Upload the QR code image to S3 s3_client.put_object( Bucket=bucket_name, Key=file_name, Body=qr_byte_arr, ContentType=\"image/png\", Metadata={\"url\": url, \"email\": body.get(\"email\")}, ) return {\"statusCode\": 200} Essentially, our function retrieves the URL from the parameters provided by the user. It then utilizes the qrcode library to convert the URL into a QR code before storing it in the S3 bucket. Additionally, the function saves the original url along with the associated email as metadata for future reference. Now, it's configuration. functions/images/qrcode/config.pyfrom infra.services import Services class QrcodeConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Qrcode\", path=\"./functions/images\", description=\"Converts an image into a qr code\", directory=\"qrcode\", layers=[services.layers.qrcode_layer], environment={ \"BUCKET_NAME\": services.s3.images_bucket.bucket_name, }, ) services.api_gateway.create_endpoint(\"POST\", \"/images/qrcode\", function, public=True) services.s3.images_bucket.grant_write(function) Implementing the Mailer Function It's worth noting that in our previous implementation, we deliberately omitted email notifications. This exemplifies one of the advantages of serverless architecture: the ability to completely decouple functions from each other and initiate notifications through events. This is precisely the approach we're taking with the mailer function. Whenever a file is uploaded to the S3 bucket, an event will be triggered to run this Lambda function. With the assistance of metadata, the mailer Lambda function will be equipped with the necessary information to determine the appropriate email recipients for notifications. forge function mailer --description \"Sends an email based on metadata when image enters the bucket\" --belongs-to \"images\" --no-api --no-tests Here's how our updated directory looks now. functions \u251c\u2500\u2500 images \u251c\u2500\u2500 mailer \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u251c\u2500\u2500 qrcode \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u2514\u2500\u2500 main.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py Let's whip up an eye-catching HTML layout to give our email a touch of elegance. functions/images/mailer/template.html<html> <head> <style> body { font-family: Arial, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; } .container { background-color: #ffffff; margin: 10px auto; padding: 20px; max-width: 600px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); } p { font-size: 16px; line-height: 1.5; color: #555555; } .logo { display: block; margin: 0 auto 20px auto; width: 100px; height: auto; } </style> </head> <body> <div class=\"container\"> <img src=\"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\" alt=\"Lambda Forge Logo\" class=\"logo\" /> <h1>Your Image Is Ready!</h1> <p>Hello,</p> <p> We're excited to let you know that your image has been processed and is now attached to this email. </p> <p>Please check the attachment to view it.</p> <p> Made with \u2764\ufe0f by <b ><a href=\"https://docs.lambda-forge.com\" style=\"color: inherit; text-decoration: none;\" >Lambda Forge</a ></b > </p> </div> </body> </html> Time to implement the mailer functionality! functions/images/mailer/main.pyimport os import smtplib from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText import boto3 def lambda_handler(event, context): # Initialize the S3 client s3_client = boto3.client(\"s3\") # Fetch the SMTP details from the environment variables SMTP_HOST = os.environ[\"SMTP_HOST\"] SMTP_PORT = os.environ[\"SMTP_PORT\"] SMTP_USER = os.environ[\"SMTP_USER\"] SMTP_PASS = os.environ[\"SMTP_PASS\"] # Extract the bucket name and the object key from the event record = event[\"Records\"][0] bucket_name = record[\"s3\"][\"bucket\"][\"name\"] object_key = record[\"s3\"][\"object\"][\"key\"] # Fetch the image from S3 response = s3_client.get_object(Bucket=bucket_name, Key=object_key) # Extract the receiver email from the metadata receiver = response[\"Metadata\"][\"email\"] # Create the multipart email msg = MIMEMultipart() sender_name = \"Lambda Forge\" # Set the 'From' field, including both the name and the email: msg[\"From\"] = f\"{sender_name} <{SMTP_USER}>\" msg[\"To\"] = receiver msg[\"Subject\"] = \"Image Processed Successfully!\" # Join the current directory with the filename to get the full path of the HTML file current_directory = os.path.dirname(os.path.abspath(__file__)) html_path = os.path.join(current_directory, \"template.html\") # Read the HTML content html = open(html_path).read() msg.attach(MIMEText(html, \"html\")) # Attach the image image_data = response[\"Body\"].read() file_name = object_key.split(\"/\")[-1] part = MIMEApplication(image_data, Name=file_name) part[\"Content-Disposition\"] = f'attachment; filename=\"{file_name}\"' msg.attach(part) # Send the email via Gmail's SMTP server, or use another server if not using Gmail with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT) as server: server.login(SMTP_USER, SMTP_PASS) server.sendmail(SMTP_USER, receiver, msg.as_string()) This function fetches essential email-sending details from environment variables such as SMTP_HOST, SMTP_PORT, SMTP_USER, and SMTP_PASS. It then retrieves the recipient's email address from the bucket's metadata and sends an email with the QR code attached. The elegance of this approach lies in its flexibility. We can incorporate multiple image processors, including tasks like image resizing, applying color filters, facial recognition, and more. None of these processors need to handle email sending directly. By simply saving the processed image inside the bucket, the corresponding functionality is seamlessly applied. Now, let's configure our Mailer function. functions/images/mailer/config.pyfrom infra.services import Services class MailerConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Mailer\", path=\"./functions/images\", description=\"Sends an email when an image enters the bucket\", directory=\"mailer\", environment={ \"SMTP_HOST\": \"smtp.gmail.com\", \"SMTP_PORT\": \"465\", \"SMTP_USER\": services.secrets_manager.gmail_secret.secret_value_from_json(\"email\").unsafe_unwrap(), \"SMTP_PASS\": services.secrets_manager.gmail_secret.secret_value_from_json(\"password\").unsafe_unwrap(), }, ) services.s3.images_bucket.grant_read(function) services.s3.create_trigger(services.s3.images_bucket, function) With our existing setup, we configure the environment variables and grant read permissions to the function for accessing the bucket. Additionally, we utilize Forge's helper method to establish a trigger that activates when an object is created in the bucket, invoking the function. Mitigating Security Risks in Mailer Configuration Although the /mailer/config.py file may seem functional, its implementation poses a significant security risk. Hardcoding credentials directly into environment variables exposes them to potential breaches, as the secret will be visible on the Lambda Function panel. To mitigate this risk, let's modify our main.py file slightly. Instead of retrieving the Gmail credentials from environment variables, we'll directly retrieve them from AWS Secrets Manager. functions/images/mailer/main.py11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31def lambda_handler(event, context): # Initialize the S3 client s3_client = boto3.client(\"s3\") # Fetch the SMTP details from the environment variables SMTP_HOST = os.environ[\"SMTP_HOST\"] SMTP_PORT = os.environ[\"SMTP_PORT\"] import json # Initialize the Secrets Manager client sm_client = boto3.client('secretsmanager') secret_name = '$SECRET-NAME' # Retrieve the secret value from Secrets Manager response = sm_client.get_secret_value(SecretId=secret_name) secret = json.loads(response['SecretString']) # Extract SMTP credentials from the secret data SMTP_USER = secret[\"email\"] SMTP_PASS = secret[\"password\"] That's quite a bit of boilerplate code for such a straightforward task! \ud83d\ude30 Considering the critical importance of security, we'll probably employ this code snippet in numerous functions. Creating a Custom Layer to Avoid Code Duplication To avoid duplicating the previous code throughout our project, let's establish a new sm_utils custom layer. This approach will streamline the process, allowing all lambda functions that need to retrieve a secret from Secrets Manager to do so with just a single line of code. Check out AWS Lambda Development with Custom Layers to delve deeper into custom layers in Lambda development. To create the new custom layer, simply type: forge layer --custom sm_utils This command creates the following directory: layers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 sm_utils \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 sm_utils.py Additionally, a new layer has been incorporated into the Layers class. infra/services/layers 5 6 7 8 9 10 11 12 13 14 15 16 17 self.qrcode_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"QrCodeLayer\", layer_version_arn=\"arn:aws:lambda:us-east-2:211125768252:layer:QRCode:1\", ) self.sm_utils_layer = _lambda.LayerVersion( scope, id='SmUtilsLayer', code=_lambda.Code.from_asset(Path.layer('layers/sm_utils')), compatible_runtimes=[_lambda.Runtime.PYTHON_3_9], description='', ) Now, it's time to level up the sm_utils layer by introducing a get_secret function. This handy feature will be shared across all our Lambda functions, simplifying our codebase. layers/sm_utils/sm_utils.pyimport json import boto3 def get_secret(secret_name: str): # Initialize the Secrets Manager client sm_client = boto3.client(\"secretsmanager\") # Retrieve the secret value from Secrets Manager response = sm_client.get_secret_value(SecretId=secret_name) # Handle scenarios where the secret is stored as plain text instead of JSON. try: secret = json.loads(response[\"SecretString\"]) except json.JSONDecodeError: secret = response[\"SecretString\"] return secret Refactoring The Mailer Function to Use Custom Layers Below is the updated main.py file, now leveraging the new sm_utils layer. functions/images/mailer/main.pyimport os import smtplib from email.mime.application import MIMEApplication from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText import boto3 import sm_utils def lambda_handler(event, context): # Initialize the S3 client s3_client = boto3.client(\"s3\") # Fetch the SMTP details from the environment variables SMTP_HOST = os.environ[\"SMTP_HOST\"] SMTP_PORT = os.environ[\"SMTP_PORT\"] # Get the secret name from env variable SECRET_NAME = os.environ[\"SECRET_NAME\"] # Get the secret from sm_utils layer secret = sm_utils.get_secret(SECRET_NAME) SMTP_USER = secret[\"email\"] SMTP_PASS = secret[\"password\"] # Extract the bucket name and the object key from the event record = event[\"Records\"][0] bucket_name = record[\"s3\"][\"bucket\"][\"name\"] object_key = record[\"s3\"][\"object\"][\"key\"] # Fetch the image from S3 response = s3_client.get_object(Bucket=bucket_name, Key=object_key) # Extract the receiver email from the metadata receiver = response[\"Metadata\"][\"email\"] # Create the multipart email msg = MIMEMultipart() sender_name = \"Lambda Forge\" # Set the 'From' field, including both the name and the email: msg[\"From\"] = f\"{sender_name} <{SMTP_USER}>\" msg[\"To\"] = receiver msg[\"Subject\"] = \"Image Processed Successfully!\" # Join the current directory with the filename to get the full path of the HTML file current_directory = os.path.dirname(os.path.abspath(__file__)) html_path = os.path.join(current_directory, \"template.html\") # Read the HTML content html = open(html_path).read() msg.attach(MIMEText(html, \"html\")) # Attach the image image_data = response[\"Body\"].read() file_name = object_key.split(\"/\")[-1] part = MIMEApplication(image_data, Name=file_name) part[\"Content-Disposition\"] = f'attachment; filename=\"{file_name}\"' msg.attach(part) # Send the email via Gmail's SMTP server, or use another server if not using Gmail with smtplib.SMTP_SSL(SMTP_HOST, SMTP_PORT) as server: server.login(SMTP_USER, SMTP_PASS) server.sendmail(SMTP_USER, receiver, msg.as_string()) Now, let's adjust the configuration to accommodate the changes necessary for the function. functions/images/mailer/config.pyfrom infra.services import Services class MailerConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Mailer\", path=\"./functions/images\", description=\"Sends an email when an image enters the bucket\", directory=\"mailer\", layers=[services.layers.sm_utils_layer], environment={ \"SMTP_HOST\": \"smtp.gmail.com\", \"SMTP_PORT\": \"465\", \"SECRET_NAME\": services.secrets_manager.gmail_secret.secret_name, }, ) services.s3.images_bucket.grant_read(function) services.s3.create_trigger(services.s3.images_bucket, function) services.secrets_manager.gmail_secret.grant_read(function) Deploying The Functions Next, we'll commit our code and push it to GitHub, following these steps: # Send your changes to stage git add . # Commit with a descriptive message git commit -m \"Image to QR code converter with result being sent by email\" # Push changes to the 'dev' branch git push origin dev # Merge 'dev' into 'staging' and push git checkout staging git merge dev git push origin staging # Finally, merge 'staging' into 'main' and push git checkout main git merge staging git push origin main This process guarantees that our code transitions systematically through the development, staging, and production environments. It activates our three specialized deployment pipelines, as illustrated by the pipelines running in the accompanying image. Following the successful execution of these pipelines, the Image to QR code feature becomes accessible across the development, staging, and production stages, ensuring a seamless deployment. Testing the Image to QR Code Conversion We'll walk through testing our Image to QR Code Converter, focusing on the production environment for this demonstration. The procedure remains consistent across development and staging environments, with the only difference being the specific endpoints used. To convert an image URL into a QR code, we execute the following POST request: curl --request POST \\ --url https://api.lambda-forge.com/images/qrcode \\ --header 'Content-Type: application/json' \\ --data '{ \"url\": \"https://public-lambda-forge-logo.s3.us-east-2.amazonaws.com/wNSN2U7n9NiAKEItWlsrcdJ0RWFyZOmbNvsc6Kht84WsWVxuBz5O.png\", \"email\": \"$EMAIL\" }' Shortly after the request is made, an email is dispatched to the provided address. The email contains a QR code attachment, as seen in the illustration below: Upon scanning the QR code, the original image is displayed: \ud83c\udf89 Success! The Image to QR Code Converter function is now fully deployed and operational in all environments. \ud83d\ude80\u2728 Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/home/securing-endpoints/",
    "title": "Securing Endpoints - Lambda Forge",
    "content": "Securing Endpoints - Lambda Forge Skip to content Lambda Forge Securing Endpoints Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Securing Endpoints Table of contents Creating an Authorizer Authorizer Structure Implementing The Authorizer Configuring The Authorizer Adding Authorizer To Lambda Stack Creating a Private Function Implementing the Function Configuring the Function as Private Deployment Process for Both Authorizer and Function Setting a Default Authorizer Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Creating an Authorizer Authorizer Structure Implementing The Authorizer Configuring The Authorizer Adding Authorizer To Lambda Stack Creating a Private Function Implementing the Function Configuring the Function as Private Deployment Process for Both Authorizer and Function Setting a Default Authorizer Securing Endpoints Through an Authorizer In this section, we will delve into securing endpoints by introducing an intermediary function known as an authorizer which will be responsible for validating incoming requests, determining if they should be allowed to access the targeted resources. By implementing an authorizer, you can ensure that only authenticated and authorized requests are processed by your endpoints, enhancing the security and privacy of your application. In fact, Lambda Forge treats all lambda functions as private by default. That's why we had to use the --public flag when creating the previous hello world function, to make it accessible without authentication. Without this flag, we would have been required to implement an authorizer for user authentication. Creating an Authorizer First, let's begin by creating a new authorizer function with the following command: forge authorizer secret --description \"An authorizer to validate requests based on a secret present on the headers\" This command instructs the forge CLI tool to create a new authorizer under the secret directory. Authorizer Structure Authorizers, while closely resembling Lambda Functions in structure, they fulfill a distinct role. Let's examine the structure of an authorizer more closely: authorizers \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 secret \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 unit.py \u2514\u2500\u2500 utils \u2514\u2500\u2500 __init__.py authorizers/ This directory serves as the central hub for all authorizer functions, analogous to how the functions/ directory houses Lambda functions. Each distinct authorizer is allocated its own subdirectory within this folder. secret/ This subdirectory is specifically designed for developing the secret authorizer. __init__.py Marks the directory as a Python package, enabling its modules to be imported elsewhere within the project. config.py Contains the configuration settings for the authorizer, such as environmental variables and access control parameters. main.py Houses the main logic for the authorizer, detailing how incoming requests are verified. unit.py Focused on unit testing for the authorizer, these tests ensure that each part of the authorizer's code operates as expected independently. utils/ Provides utility functions that are used by the authorizers, offering common functionalities or resources that can be leveraged across various authorizers. Implementing The Authorizer Forge automatically generates a basic implementation of an AWS Lambda authorizer that checks for a secret value present on the headers to decide on granting or denying access. Warning The example below is intended solely for demonstration and learning purposes and should not be used in production environemnts. It is crucial to develop a comprehensive and secure authentication mechanism suitable for your application's security needs. authorizers/secret/main.pydef lambda_handler(event, context): # ATTENTION: The example provided below is strictly for demonstration purposes and should NOT be deployed in a production environment. # It's crucial to develop and integrate your own robust authorization mechanism tailored to your application's security requirements. # To utilize the example authorizer as a temporary placeholder, ensure to include the following header in your requests: # Header: # secret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8 # Remember, security is paramount. This placeholder serves as a guide to help you understand the kind of information your custom authorizer should authenticate. # Please replace it with your secure, proprietary logic before going live. Happy coding! secret = event[\"headers\"].get(\"secret\") SECRET = \"CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8\" effect = \"allow\" if secret == SECRET else \"deny\" policy = { \"policyDocument\": { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": \"execute-api:Invoke\", \"Effect\": effect, \"Resource\": event[\"methodArn\"] } ], }, } return policy The code snippet above demonstrates that the authorizer is configured to verify the presence of a header named secret in the request, as shown below: secret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8 This key serves as a simple form of authentication, granting or denying access based on its presence and accuracy in the request headers. The secret mentioned is automatically generated by Forge, meaning the specific secret you encounter during your implementation will differ from the example provided. Please be mindful of this distinction as you proceed. Configuring The Authorizer Similar to lambda functions in terms of setup, authorizers diverge in their application. Instead of establishing an endpoint on API Gateway, an authorizer is configured to control access to one or more endpoints. authorizers/secret/config.py 1 2 3 4 5 6 7 8 9 10 11 12from infra.services import Services class SecretAuthorizerConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"SecretAuthorizer\", path=\"./authorizers/secret\", description=\"An authorizer to validate requests based on a secret present on the headers\" ) services.api_gateway.create_authorizer(function, name=\"secret\") The configuration detailed above establishes a new authorizer, assigning it a unique identifier secret within the API Gateway. Adding Authorizer To Lambda Stack Similarly to the functions, an authorizer needs to be initialized within the LambdaStack class. Fortunately, Forge takes care of this automatically. infra/stacks/lambda_stack.pyfrom aws_cdk import Stack from constructs import Construct from infra.services import Services from lambda_forge import release from authorizers.secret.config import SecretAuthorizerConfig from functions.hello_world.config import HelloWorldConfig @release class LambdaStack(Stack): def __init__(self, scope: Construct, context, **kwargs) -> None: super().__init__(scope, f\"{context.name}-Lambda-Stack\", **kwargs) self.services = Services(self, context) # Authorizers SecretAuthorizerConfig(self.services) # HelloWorld HelloWorldConfig(self.services) Creating a Private Function Now let's create a new private function. forge function private --method \"GET\" --description \"A private function\" Upon creating a new function using the Forge CLI, the project's function structure is expanded to include this new function alongside the existing ones. functions \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 hello_world \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 config.py \u2502 \u251c\u2500\u2500 integration.py \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 unit.py \u2514\u2500\u2500 private \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config.py \u251c\u2500\u2500 integration.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 unit.py Implementing the Function Let's make some adjustments to the response returned by this Lambda function: functions/private/main.py13 14 15 16 17 18def lambda_handler(event, context): return { \"statusCode\": 200, \"body\": json.dumps({\"message\": \"Hello From Private!\"}) } Rather than displaying the message Hello World!, we will now return Hello From Private!. Additionally, let's revise the unit tests to accurately represent the modifications we've implemented in our code. functions/private/unit.pyimport json from .main import lambda_handler def test_lambda_handler(): response = lambda_handler(None, None) assert response[\"body\"] == json.dumps({\"message\": \"Hello From Private!\"}) Configuring the Function as Private To configure the function as private, we must link it to the authorizer by passing the authorizer's name, established during its creation, to the create_endpoint method. functions/private/config.pyfrom infra.services import Services class PrivateConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Private\", path=\"./functions/private\", description=\"A private function\", ) services.api_gateway.create_endpoint(\"GET\", \"/private\", function, authorizer=\"secret\") This configuration file establishes a new private function that is secured with the secrets authorizer and accessible via a GET request at the /private endpoint. Deployment Process for Both Authorizer and Function As the next step, let's proceed to upload our updates to GitHub. # Add all changes to the staging area git add . # Commit the staged changes with a clear message git commit -m \"Implemented a private function with an authorizer\" # Push the committed changes to the 'dev' branch git push origin dev This operation will automatically initiate our development pipeline. After the pipeline completes successfully, the private Lambda function becomes operational: Dev: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/private Direct access to these URLs through a web browser will display an unauthorized access message: { \"Message\": \"User is not authorized to access this resource with an explicit deny\" } However, access is granted when including the necessary secret in the request header. Below is how to use curl to access the Lambda function: curl --request GET \\ --url https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/private \\ --header 'secret: CRMdDRMA4iW4xo9l38pACls7zsHYfp8T7TLXtucysb2lB5XBVFn8' Upon running the curl command, you will receive the following response: { \"message\": \"Hello From Private!\" } This validates the functionality of our authorizer, effectively securing the private Lambda function to ensure access is only available to those possessing the correct secret header. Setting a Default Authorizer Lambda Forge automatically considers all functions as private unless specified otherwise. This means functions are generally expected to require an authorizer for access control, unless they are explicitly marked as public. To facilitate easier management and to obviate the need for specifying an authorizer for each Lambda function individually, Lambda Forge allows for the designation of a default authorizer. This default authorizer is automatically applied to all non-public Lambda functions, streamlining the configuration process for securing access. To set an authorizer as the default, you can use the default=True argument in the create_authorizer method when defining your authorizer. authorizers/secret/config.py 6 7 8 9 10 11 12 function = services.aws_lambda.create_function( name=\"SecretAuthorizer\", path=\"./authorizers/secret\", description=\"An authorizer to validate requests based on a secret present on the headers\" ) services.api_gateway.create_authorizer(function, name=\"secret\", default=True) Next, we'll update the Private Function configuration to no longer directly associate it with the secrets authorizer. functions/private/config.py 6 7 8 9 10 11 12 function = services.aws_lambda.create_function( name=\"Private\", path=\"./functions/private\", description=\"A private function\", ) services.api_gateway.create_endpoint(\"GET\", \"/private\", function) Having designated the secretauthorizer as the default, any function not explicitly linked to a particular authorizer and not flagged as public, such as this one, will inherently be protected by the secret authorizer by default. Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/home/lambda-layers/",
    "title": "Lambda Layers - Lambda Forge",
    "content": "Lambda Layers - Lambda Forge Skip to content Lambda Forge Lambda Layers Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Creating a Hello World Securing Endpoints Lambda Layers Lambda Layers Table of contents What Are Lambda Layers? How They Work Use Cases AWS Lambda Development with Custom Layers Creating a Custom Layer Creating a Lambda Function Utilizing the Custom Layer AWS Lambda Development with External Libraries Incorporating Requests from Public Layers Creating a Lambda Function Utilizing the Requests Library Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents What Are Lambda Layers? How They Work Use Cases AWS Lambda Development with Custom Layers Creating a Custom Layer Creating a Lambda Function Utilizing the Custom Layer AWS Lambda Development with External Libraries Incorporating Requests from Public Layers Creating a Lambda Function Utilizing the Requests Library Utilizing Lambda Layers for Code Reuse and External Library Integration What Are Lambda Layers? Lambda Layers are essentially ZIP archives containing libraries, custom runtime environments, or other dependencies. You can include these layers in your Lambda function\u2019s execution environment without having to bundle them directly with your function's deployment package. This means you can use libraries or custom runtimes across multiple Lambda functions without needing to include them in each function\u2019s codebase. How They Work When you create a Lambda function, you specify which layers to include in its execution environment. During execution, AWS Lambda configures the function's environment to include the content of the specified layers. This content is available to your function's code just as if it were included in the deployment package directly. Use Cases Sharing code: Commonly used code can be placed in a layer and shared among multiple functions. Custom runtimes: You can use layers to deploy functions in languages that AWS Lambda does not natively support by including the necessary runtime in a layer. Configuration files: Layers can be used to store configuration files that multiple functions need to access. AWS Lambda Development with Custom Layers Forge streamlines the process of creating and sharing custom layers across AWS Lambda functions, significantly simplifying code reuse and management. This section walks you through creating a custom layer using Forge, integrating it into your development workflow, and utilizing it within a Lambda function. Creating a Custom Layer To begin, execute the following command to create a custom layer named my_custom_layer: forge layer --custom my_custom_layer This command sets up a specific directory structure for your layer within your project, organizing the code efficiently: layers \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 my_custom_layer \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 my_custom_layer.py Forge not only initializes the necessary structure but also populates my_custom_layer.py with a starter function. This function acts as a blueprint for your shared code: layers/my_custom_layer/my_custom_layer.pydef hello_from_layer(): return \"Hello from my_custom_layer layer!\" Additionally, Forge sets the new custom layer in the Layers class. infra/services/layers.pyfrom aws_cdk import aws_lambda as _lambda from lambda_forge import Path class Layers: def __init__(self, scope) -> None: self.my_custom_layer = _lambda.LayerVersion( scope, id='MyCustomLayer', code=_lambda.Code.from_asset(Path.layer('layers/my_custom_layer')), compatible_runtimes=[_lambda.Runtime.PYTHON_3_9], description='', ) Traditionally, working with Lambda layers introduces complexity during development. Since Lambda layers are deployed as zip files and run within the Lambda execution environment, developers usually face challenges in utilizing these layers locally. This often leads to a disconnect between development and production environments, complicating the development process. When you create a custom layer using Forge, the new layer is automatically integrated into your local virtual environment, similar to installing an external library from pip. However, to ensure that these changes are fully recognized, you may need to reload your IDE or reselect your virtual environment. Note In case you need to reinstall the custom layers into your virtual environment, use the command: forge layers --install Creating a Lambda Function Utilizing the Custom Layer Create a new Lambda function that leverages your custom layer by running: forge function custom --method \"GET\" --description \"A function that uses my_custom_layer\" --public This command simply creates a public function named custom inside the functions directory. functions \u2514\u2500\u2500 custom \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config.py \u251c\u2500\u2500 integration.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 unit.py Now, implement the function to utilize the custom layer: functions/layers/custom/main.pyimport json from dataclasses import dataclass import my_custom_layer @dataclass class Input: pass @dataclass class Output: message: str def lambda_handler(event, context): message = my_custom_layer.hello_from_layer() return {\"statusCode\": 200, \"body\": json.dumps({\"message\": message})} Also, update the unit tests to expect the correct output message: functions/layers/custom/unit.pyimport json from .main import lambda_handler def test_lambda_handler(): response = lambda_handler(None, None) assert response[\"body\"] == json.dumps({\"message\": \"Hello from my_custom_layer layer!\"}) Finally, configure the function to make use of the my_custom_layer layer: functions/layers/custom/config.pyfrom infra.services import Services class CustomConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"Custom\", path=\"./functions/custom\", description=\"A function to make use of the custom layer\", layers=[services.layers.my_custom_layer], ) services.api_gateway.create_endpoint(\"GET\", \"/custom\", function, public=True) Once you've committed and pushed your code to GitHub and the pipeline has successfully executed, making a GET request to the generated URL should return the following response: { \"message\": \"Hello from my_custom_layer layer!\" } The URL for this tutorial is: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/custom AWS Lambda Development with External Libraries In software development, using external libraries is a common practice to extend functionality and streamline the development process. When working with AWS Lambda, incorporating these external libraries requires integrating them as layers into our Lambda functions. To illustrate this scenario, we will develop a new lambda function aimed to parsing the data retrieved from the external API https://randomuser.me/api/, a public service for generating random fake user data. Since the requests library is not inherently included in Python, it will be necessary to integrate it as a layer in our lambda function. Incorporating Requests from Public Layers The requests library is widely used and recognized for its utility. Fortunately, AWS Lambda offers this library as public layers, simplifying the process of integrating them into your projects without the need to create custom layers. For projects utilizing Python 3.9, we can leverage the specific Amazon Resource Names (ARNs) for the requests library made available through Klayers. This provides an efficient way to add these libraries to your Lambda functions. You can explore the complete list of public layers for Python 3.9 in the us-east-2 region here. Here is the ARN you'll need: Requests: arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19 Let's proceed by manually incorporating it into our Layers class. infra/services/layers.py 8 9 10 11 12 13 14 15 16 17 18 19 20 self.my_custom_layer = _lambda.LayerVersion( scope, id='MyCustomLayer', code=_lambda.Code.from_asset(Path.layer('layers/my_custom_layer')), compatible_runtimes=[_lambda.Runtime.PYTHON_3_9], description='', ) self.requests_layer = _lambda.LayerVersion.from_layer_version_arn( scope, id=\"RequestsLayer\", layer_version_arn=\"arn:aws:lambda:us-east-2:770693421928:layer:Klayers-p39-requests:19\", ) Additionally, include it in the requirements.txt file. requirements.txt16requests==2.28.1 Creating a Lambda Function Utilizing the Requests Library To create a Lambda function that leverages the Requests library, execute the following command: forge function external --method \"GET\" --description \"A function that uses an external library\" --public This command creates a new function named external inside the functions directory. functions \u2514\u2500\u2500 external \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 config.py \u251c\u2500\u2500 integration.py \u251c\u2500\u2500 main.py \u2514\u2500\u2500 unit.py Now, implement the function to utilize the custom layer: import json from dataclasses import dataclass import requests @dataclass class Input: pass @dataclass class Name: title: str first: str last: str @dataclass class Output: name: Name gender: str email: str def lambda_handler(event, context): result = requests.get(\"https://randomuser.me/api\").json()[\"results\"][0] data = { \"name\": result[\"name\"], \"gender\": result[\"gender\"], \"email\": result[\"email\"], } return {\"statusCode\": 200, \"body\": json.dumps({\"data\": data})} Additionally, update the unit tests to expect the correct output message: functions/layers/external/unit.pyimport json from .main import lambda_handler def test_lambda_handler(): response = lambda_handler(None, None) body = json.loads(response[\"body\"]) assert [\"name\", \"gender\", \"email\"] == list(body.keys()) Finally, configure the function to make use of the requests layer: functions/layers/custom/config.pyfrom infra.services import Services class ExternalConfig: def __init__(self, services: Services) -> None: function = services.aws_lambda.create_function( name=\"External\", path=\"./functions/external\", description=\"A function that uses an external library\", layers=[services.layers.requests_layer], ) services.api_gateway.create_endpoint(\"GET\", \"/external\", function, public=True) Once you've committed and pushed your code to GitHub and the pipeline has successfully executed, making a GET request to the generated URL should return the following response: { \"name\": { \"title\": \"str\", \"first\": \"str\", \"last\": \"str\" }, \"gender\": \"str\", \"email\": \"str\" } For this tutorial, the generated URL is: https://gxjca0e395.execute-api.us-east-2.amazonaws.com/dev/external Back to top \u00a9 2024 Guilherme Alves Pimenta"
  },
  {
    "url": "https://docs.lambda-forge.com/home/getting-started/",
    "title": "Getting Started - Lambda Forge",
    "content": "Getting Started - Lambda Forge Skip to content Lambda Forge Getting Started Initializing search Home Docs Example Projects Articles License Lambda Forge Home Docs Docs Introduction Getting Started Getting Started Table of contents Install and Configure AWS CDK Create a GitHub Personal Access Token Store the Token on AWS Secrets Manager Create a New Directory Create a New Virtual Environment Install lambda-forge Forge CLI Verify Installation Create a New Project Project Structure Creating a Hello World Securing Endpoints Lambda Layers Multi-Stage Environments Custom CodePipeline Steps Docs Generation Pre-Commit Hooks Example Projects Example Projects Introduction Begginer Begginer Guess The Number URL Shortener Image to QR Code Converter Intermediate Intermediate JWT Authentication OAuth2 Authentication Real-Time Chat Web Scraper Advanced Advanced Data Processing Pipeline Stock Price Tracker Articles Articles Custom Domain Name Tests with Lambda Forge Deploying External Library as Layers Creating S3 Buckets Locating the Base URL JSON Web Tokens License Table of contents Install and Configure AWS CDK Create a GitHub Personal Access Token Store the Token on AWS Secrets Manager Create a New Directory Create a New Virtual Environment Install lambda-forge Forge CLI Verify Installation Create a New Project Project Structure Getting Started Install and Configure AWS CDK Lambda Forge is built on top of AWS Cloud Development Kit (CDK) and it's essential for defining cloud infrastructure in code and provisioning it through AWS CloudFormation. Execute the following commands to install the AWS CDK globally and set up your AWS credentials: npm install -g aws-cdk aws configure cdk bootstrap During the configuration, you will be prompted to enter your AWS Access Key ID, Secret Access Key, default region name, and output format. Create a GitHub Personal Access Token Lambda Forge uses CodePipeline to interact with your GitHub repository. To enable this, generate a GitHub personal access token by following these steps: Navigate to \"Developer Settings\" in your GitHub account. Select \"Personal access tokens,\" then \"Tokens (classic).\" Click \"Generate new token,\" ensuring the \"repo\" scope is selected for full control of private repositories. Complete the token generation process. You can find more informations about creating a GitHub Token here. Your token will follow this format: ghp_******************************** Store the Token on AWS Secrets Manager Save this token in AWS Secrets Manager as plain text using the exact name github-token. This specific naming is vital as it corresponds to the default identifier that the CDK looks for within your AWS account. Create a New Directory mkdir lambda_forge_demo cd lambda_forge_demo Create a New Virtual Environment python3 -m venv venv source venv/bin/activate Install lambda-forge pip install lambda-forge --extra-index-url https://pypi.org/simple --extra-index-url https://test.pypi.org/simple/ Forge CLI The Forge Command Line Interface (CLI) is a powerful, versatile tool designed to streamline the development, deployment, and management of applications. It enables developers to automate repetitive tasks, manage project configurations, and interact directly with the services and infrastructure without leaving the terminal. This CLI tool simplifies complex processes through straightforward commands, significantly reducing development time and effort. Verify Installation Having successfully installed Lambda Forge, you are now ready to explore the capabilities of the Forge CLI. Begin by entering the following command to access the comprehensive list of available options and commands: forge --help Here's a concise list of the commands supported by Forge: Commands: authorizer Create a new authorizer function Create a new function layer Create a new layer project Create a new project service Create a new AWS service For a comprehensive list of configurations that each Forge command supports, you can refer to the command line help by running: forge $COMMAND --help. Later in this tutorial, we'll delve into the specifics of each command. But for now, let's kickstart by establishing the foundation of our project. Create a New Project Start a new project named lambda-forge-demo, incorporating the --no-docs flag to bypass docs generation initially as this will be covered on a dedicated section. forge project lambda-forge-demo --repo-owner \"$GITHUB-OWNER\" --repo-name \"$GITHUB-REPO\" --no-docs Make sure to replace $GITHUB-OWNER and $GITHUB-REPO with the actual GitHub owner and the name of an empty repository. Project Structure Upon creatig your project, some directories and files are automatically generated for you. This initial structure is designed to streamline the setup process and provide a solid foundation for further development. In the upcoming sections of this tutorial, we'll explore each of these components in detail. For now, familiarize yourself with the foundational structure that should resemble the following: . \u251c\u2500\u2500 authorizers \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 functions \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 infra \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 services \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u251c\u2500\u2500 api_gateway.py \u2502 \u2502 \u251c\u2500\u2500 aws_lambda.py \u2502 \u2502 \u2514\u2500\u2500 layers.py \u2502 \u251c\u2500\u2500 stacks \u2502 \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2502 \u251c\u2500\u2500 dev_stack.py \u2502 \u2502 \u251c\u2500\u2500 lambda_stack.py \u2502 \u2502 \u251c\u2500\u2500 prod_stack.py \u2502 \u2502 \u2514\u2500\u2500 staging_stack.py \u2502 \u2514\u2500\u2500 stages \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 deploy.py \u251c\u2500\u2500 layers \u2502 \u2514\u2500\u2500 __init__.py \u251c\u2500\u2500 .coveragerc \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 app.py \u251c\u2500\u2500 cdk.json \u251c\u2500\u2500 pytest.ini \u2514\u2500\u2500 requirements.txt The cdk.json file, located at the root of your directory, serves as the central configuration hub for Lambda Forge projects. When you run the forge project command, Forge automatically applies the informed settings into the cdk.json file. cdk.json41 42 43 44 45 46 47 48 49 \"region\": \"us-east-2\", \"account\": \"\", \"name\": \"Lambda-Forge-Demo\", \"repo\": { \"owner\": \"$GITHUB-OWNER\", \"name\": \"$GITHUB-REPO\" }, \"bucket\": \"\", \"coverage\": 80, Back to top \u00a9 2024 Guilherme Alves Pimenta"
  }
]